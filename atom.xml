<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>布衣男儿</title>
  <subtitle>不物喜，不己悲，善假物，易参行！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huos3203.github.io/"/>
  <updated>2017-03-01T09:27:16.000Z</updated>
  <id>https://huos3203.github.io/</id>
  
  <author>
    <name>boyer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互动性的教学工具XCPlayground</title>
    <link href="https://huos3203.github.io/2017/03/01/%E4%BA%92%E5%8A%A8%E6%80%A7%E7%9A%84%E6%95%99%E5%AD%A6%E5%B7%A5%E5%85%B7XCPlayground/"/>
    <id>https://huos3203.github.io/2017/03/01/互动性的教学工具XCPlayground/</id>
    <published>2017-03-01T09:27:16.000Z</published>
    <updated>2017-03-01T09:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h2><p>打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”Sources”路径。<br>放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。</p>
<blockquote>
<p>注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。</p>
</blockquote>
<img src="/images/xcplayground-sources.png">
<h2 id="导入Frameworks"><a href="#导入Frameworks" class="headerlink" title="导入Frameworks"></a>导入Frameworks</h2><p>如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。</p>
<h3 id="手动配置cocoa-touch-Framework来桥接playground"><a href="#手动配置cocoa-touch-Framework来桥接playground" class="headerlink" title="手动配置cocoa touch Framework来桥接playground"></a>手动配置cocoa touch Framework来桥接playground</h3><p>在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接<br>注：.swift的文件中的方法必须是public修饰。<br>参考文档：<code>Playground help -&gt; Importing Custom Frameworks into a Playground</code></p>
<ol>
<li>导入个人项目文件，需要借助<code>cocoa touch Framework</code>桥接<code>playground</code></li>
<li>需要<code>workspace</code>来管理<code>Framework</code>项目和<code>playground</code>文件，典型例子：pod项目都是用workspace来管理多个项目。</li>
<li>把个人项目的<code>swift文件</code>关联到<code>Cocoa touch Framework</code>项目的<code>target</code>中：<br> 详细设置：选中target -&gt; build phases -&gt; compiles sources -&gt;点击 + 加号，选中原项目中的swift</li>
<li>在<code>build</code>选项中选中Framework的scheme进行编译 ,要保证framework的target配置：<code>build setting -&gt; build active architecture Only -&gt;debug</code>选项设置为<code>YES</code></li>
<li>打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。<br>Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致.</li>
<li>xcode的偏好设置中 -&gt;Locations -&gt; Locations -&gt;点击打开 Advanced…在弹出框中设置Unique选项.</li>
<li>在workspace中选中菜单 File -&gt; workspace settings… -&gt; 在弹出框中设置为Unique选项.</li>
</ol>
<h3 id="导入cocopads管理的依赖库"><a href="#导入cocopads管理的依赖库" class="headerlink" title="导入cocopads管理的依赖库"></a>导入cocopads管理的依赖库</h3><p>xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库<br>解决办法：<a href="http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#" target="_blank" rel="external">http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在写入磁盘之前，修改一些工程的配置:</span></div><div class="line">post_install <span class="keyword">do</span> |installer|</div><div class="line">    installer.pods_project.targets.each <span class="keyword">do</span> |target|</div><div class="line">        <span class="keyword">if</span> target.name != <span class="string">'CocoaAsyncSocket'</span></div><div class="line">            <span class="comment">#playground相关配置，会导致'GCDAsyncSocket.h' file not found</span></div><div class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</div><div class="line">                config.build_settings[<span class="string">'CONFIGURATION_BUILD_DIR'</span>] = <span class="string">'$PODS_CONFIGURATION_BUILD_DIR'</span></div><div class="line"></div><div class="line">                <span class="comment">#Use Legacy Swift Language Version” (SWIFT_VERSION):</span></div><div class="line">                <span class="comment">#   https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685</span></div><div class="line">                puts <span class="string">"SWIFT_VERSIION:"</span></div><div class="line">                config.build_settings[<span class="string">'SWIFT_VERSION'</span>] = <span class="string">"3.0.1"</span></div><div class="line">                puts config.build_settings[<span class="string">'SWIFT_VERSION'</span>]</div><div class="line">            end</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">#输出操作</span></div><div class="line">            puts <span class="string">"以下不能在playground中使用的库名："</span></div><div class="line">            puts target.name</div><div class="line">        end</div><div class="line">    end</div><div class="line">end</div></pre></td></tr></table></figure></p>
<h2 id="Playground沙盒Resources"><a href="#Playground沙盒Resources" class="headerlink" title="Playground沙盒Resources"></a>Playground沙盒Resources</h2><p>Playgrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。</p>
<h2 id="本地-bundle访问本地资源"><a href="#本地-bundle访问本地资源" class="headerlink" title="本地 bundle访问本地资源"></a>本地 bundle访问本地资源</h2><p>Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonPath = <span class="type">NSBundle</span>.mainBundle().bundlePath.stringByAppendingPathComponent(<span class="string">"weather.json"</span>)</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span></div><div class="line">jsonData = <span class="type">NSData</span>(contentsOfFile: jsonPath),</div><div class="line">json = <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(jsonData, options: <span class="literal">nil</span>, error: <span class="literal">nil</span>) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>] </div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="共享-访问Documents共享目录"><a href="#共享-访问Documents共享目录" class="headerlink" title="共享 访问Documents共享目录"></a>共享 访问Documents共享目录</h2><p>“共享 Playground 数据”的内容在你的”Documents”文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。</p>
<p>如果你自习想尝试，需要在 “~/Documents/Shared Playground Data” 下简历一个文件夹。 这里我们尝试载入一个名字叫做 “image.png” 的图片文件:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sharedImagePath = <span class="type">XCPSharedDataDirectoryPath</span>.stringByAppendingPathComponent(<span class="string">"image.png"</span>)</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: sharedImagePath) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="PlaygroundSupport"><a href="#PlaygroundSupport" class="headerlink" title="PlaygroundSupport"></a>PlaygroundSupport</h2><h3 id="liveView视图代理"><a href="#liveView视图代理" class="headerlink" title="liveView视图代理"></a>liveView视图代理</h3><p>实现在playground中实现UI显示及交互操作<br>liveView定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> liveView: <span class="type">XCPlaygroundLiveViewable</span>?</div></pre></td></tr></table></figure><br>遵循了<code>XCPlaygroundLiveViewable</code>协议即可在playground中可视化显示：</p>
<ol>
<li>在iOS 和 tvOS中<code>UIView</code> and <code>UIViewController</code>遵循该协议</li>
<li>在OS X中<code>NSView</code> and <code>NSViewController</code>遵循该协议</li>
<li>用户自定类型，须遵守XCPlaygroundLiveViewable协议<br>总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。<br>用法：<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">PlaygroundPage</span>.current.liveView = <span class="type">UIView</span>()／<span class="type">NSViewController</span>()</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="捕获值（XCPCaptureValue在XCPlayground中过时）"><a href="#捕获值（XCPCaptureValue在XCPlayground中过时）" class="headerlink" title="捕获值（XCPCaptureValue在XCPlayground中过时）"></a>捕获值（XCPCaptureValue在XCPlayground中过时）</h3><p><a href="http://swifter.tips/playground-capture/" target="_blank" rel="external">冒泡排序可视化预览</a><br><figure class="highlight swift"><figcaption><span>XCPlayground Module</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// This function has been deprecated.</span></div><div class="line"><span class="meta">@available</span>(*, deprecated)</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">XCPCaptureValue</span>&lt;T&gt;<span class="params">(identifier: String, value: T)</span></span></div></pre></td></tr></table></figure></p>
<p>简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。</p>
<ol>
<li>使用：导入框架<code>import XCPlayground</code></li>
<li>扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写</li>
</ol>
<p>一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？</p>
<p>通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> XCPlayground</div><div class="line"></div><div class="line"><span class="keyword">for</span> forecast <span class="keyword">in</span> forecasts </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> tempString = forecast[<span class="string">"temp"</span>]?[<span class="string">"english"</span>] <span class="keyword">as</span>? <span class="type">String</span>, temperature = tempString.toInt()</div><div class="line">    &#123;</div><div class="line">        <span class="type">XCPCaptureValue</span>(<span class="string">"Temperature"</span>, temperature)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中：</p>
<img src="/images/xcplayground-capture.png">
<h3 id="异步执行（Asynchronous-Execution）"><a href="#异步执行（Asynchronous-Execution）" class="headerlink" title="异步执行（Asynchronous Execution）"></a>异步执行（Asynchronous Execution）</h3><p>不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。<br>这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。<br><code>PlaygroundSupport</code> 模块包含一个能够延长该过程的函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> needsIndefiniteExecution: <span class="type">Bool</span></div></pre></td></tr></table></figure></p>
<ol>
<li>开启异步：默认值为<code>false</code>,当使用liveView代理时，会自动设置为<code>true</code>。当为<code>true</code>时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为<code>false</code>时，当代码执行完直接终止。</li>
<li>手动终止：还可以使用<code>PlaygroundPage.finishExecution()</code>手动终止正在运行的Playground。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> PlaygroundSupport</div><div class="line"></div><div class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"http://httpbin.org/image/png"</span>)!</div><div class="line"><span class="keyword">let</span> task = <span class="type">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123;</div><div class="line">    data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(data: data)</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    </div><div class="line">        <span class="comment">//手动终止</span></div><div class="line">        <span class="type">PlaygroundPage</span>.current.currentPage.finishExecution()</div><div class="line">&#125;</div><div class="line">task.resume()</div></pre></td></tr></table></figure>
<h2 id="支持Markdown格式的文档"><a href="#支持Markdown格式的文档" class="headerlink" title="支持Markdown格式的文档"></a>支持Markdown格式的文档</h2><p><a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/" target="_blank" rel="external">官方文档</a><br>除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。</p>
<p>不同于<a href="http://nshipster.cn/swift-documentation/" target="_blank" rel="external">Swift代码中的注释文档语法</a>, <code>Swift Playgrounds</code> 使用 <code>Markdown</code> 来显示多格式的文档。<br>例如：<br><code>//:</code>：可以指定单行文本说明<br><code>/*: Markdown格式内容... */</code>：可以用<code>Markdown</code>格式来显示丰富的文档内容</p>
<p>xcode8中不再支持选择切换到获得多格式文档操作：</p>
<ol>
<li><del>选择<code>Editor → Show Rendered Markup</code> 菜单</del></li>
<li><del>在 <code>File Inspector (⌘⌥1)</code> 选中 <code>Render Documentation</code> 复选框。</del></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//: This line will have **bold** and *italic* text.</span></div><div class="line"></div><div class="line"><span class="comment">/*:</span></div><div class="line">## Headers of All Sizes</div><div class="line"></div><div class="line">### Lists of Links</div><div class="line"></div><div class="line">- [NSHipster](http://nshipster.com)</div><div class="line">- [ASCIIwwdc](http://asciiwwdc.com)</div><div class="line">- [SwiftDoc](http://swiftdoc.org)</div><div class="line"></div><div class="line">### Images, Too</div><div class="line"></div><div class="line">![Remote Image](http://nshipster.s3.amazonaws.com/alert.gif)</div><div class="line">![Local Image](bomb.gif) </div><div class="line"></div><div class="line">*Images in the Resources directory can be referenced locally*</div><div class="line">*/</div><div class="line"></div></pre></td></tr></table></figure>
<img src="/images/xcplayground-documentation.png">
<p>Playgrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Sources&quot;&gt;&lt;a href=&quot;#Sources&quot; class=&quot;headerlink&quot; title=&quot;Sources&quot;&gt;&lt;/a&gt;Sources&lt;/h2&gt;&lt;p&gt;打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”
    
    </summary>
    
      <category term="swift" scheme="https://huos3203.github.io/categories/swift/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="语法" scheme="https://huos3203.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="测试" scheme="https://huos3203.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Cocoapods创建私有podspec</title>
    <link href="https://huos3203.github.io/2017/02/28/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89podspec/"/>
    <id>https://huos3203.github.io/2017/02/28/使用Cocoapods创建私有podspec/</id>
    <published>2017-02-28T07:46:16.000Z</published>
    <updated>2017-02-28T08:52:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="repo-add命令添加自己的索引库"><a href="#repo-add命令添加自己的索引库" class="headerlink" title="repo add命令添加自己的索引库"></a>repo add命令添加自己的索引库</h2><p>在github登录个人账号：并创建一个库作为pod索引托管库。<br>也可根据具体情况可以选择：<code>github</code>、<code>CODING</code>、<code>开源中国</code>、<code>Bitbucket</code>以及<code>CSDN</code>等，代码托管平台。<br>当项目托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。<br><figure class="highlight ruby"><figcaption><span>repo add命令</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span></div><div class="line">$ pod repo add LogSwift <span class="symbol">https:</span>/<span class="regexp">/coding.net/git</span><span class="regexp">/LogSwift.git</span></div></pre></td></tr></table></figure><br>此时 <code>~/.cocoapods/repos</code>目录下就可以看到<code>LogSwift</code>这个目录。</p>
<h2 id="创建Pod工程模版项目-lib-create"><a href="#创建Pod工程模版项目-lib-create" class="headerlink" title="创建Pod工程模版项目 lib create"></a>创建Pod工程模版项目 lib create</h2><p>初始化Pod项目：<br><figure class="highlight ruby"><figcaption><span>lib create命令</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib create LogSwift</div></pre></td></tr></table></figure><br>有以下五步命令行交互：<br><figure class="highlight ruby"><figcaption><span>交互</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">What is your email?</div><div class="line">&gt; </div><div class="line">What language <span class="keyword">do</span> you want to use?? [ Swift / ObjC ]</div><div class="line">&gt;Swift</div><div class="line">Would you like to <span class="keyword">include</span> a demo application with your library? [ Yes / No ]</div><div class="line">&gt;Yes</div><div class="line">Which testing frameworks will you use? [ Quick / None ]</div><div class="line">&gt;Quick</div><div class="line">Would you like to <span class="keyword">do</span> view based testing? [ Yes / No ]</div><div class="line">&gt;</div></pre></td></tr></table></figure><br>会自动执行<code>pod install</code>命令创建项目并生成依赖。</p>
<h3 id="添加库文件和资源"><a href="#添加库文件和资源" class="headerlink" title="添加库文件和资源"></a>添加库文件和资源</h3><p>例如：把一个网络模块的共有组件放入<code>Pod/Classes</code>中，然后进入<code>Example</code>文件夹执行<code>pod update</code>命令，再打开项目工程可以看到，刚刚添加的组件已经在<code>Pods</code>子工程下<code>Development Pods/PodTestLibrary</code>中了，然后编辑demo工程，测试组件。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>
<h3 id="配置podspec文件及验证命令lib-lint"><a href="#配置podspec文件及验证命令lib-lint" class="headerlink" title="配置podspec文件及验证命令lib lint"></a>配置podspec文件及验证命令lib lint</h3><h4 id="打tag号作为podspec版本号"><a href="#打tag号作为podspec版本号" class="headerlink" title="打tag号作为podspec版本号"></a>打tag号作为podspec版本号</h4><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class="highlight ruby"><figcaption><span>打标签</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -m <span class="string">"first release"</span> <span class="number">0</span>.<span class="number">1.0</span></div><div class="line">$ git push --tags     <span class="comment">#推送tag到远端仓库</span></div></pre></td></tr></table></figure></p>
<h4 id="编辑podspec文件"><a href="#编辑podspec文件" class="headerlink" title="编辑podspec文件"></a>编辑podspec文件</h4><p><code>podspec文件</code>是一个Ruby格式：<br><figure class="highlight ruby"><figcaption><span>podspec文件</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></div><div class="line">s.name             = <span class="string">"PodTestLibrary"</span>    <span class="comment">#名称</span></div><div class="line">s.version          = <span class="string">"0.1.0"</span>             <span class="comment">#版本号</span></div><div class="line">s.summary          = <span class="string">"Just Testing."</span>     <span class="comment">#简短介绍，下面是详细介绍</span></div><div class="line">s.description      = <span class="string">&lt;&lt;-DESC</span></div><div class="line">Testing Private Podspec.</div><div class="line"></div><div class="line">* Markdown format.</div><div class="line">* Don't worry about the indent, we strip it!</div><div class="line">DESC</div><div class="line">s.homepage         = <span class="string">"https://coding.net/u/wtlucky/p/podTestLibrary"</span>                           <span class="comment">#主页,这里要填写可以访问到的地址，不然验证不通过</span></div><div class="line"><span class="comment"># s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"           #截图</span></div><div class="line">s.license          = <span class="string">'MIT'</span>              <span class="comment">#开源协议</span></div><div class="line">s.author           = &#123; <span class="string">"wtlucky"</span> =&gt; <span class="string">"wtlucky@foxmail.com"</span> &#125;                   <span class="comment">#作者信息</span></div><div class="line">s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://coding.net/wtlucky/podTestLibrary.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"0.1.0"</span> &#125;      <span class="comment">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span></div><div class="line"><span class="comment"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'                       #多媒体介绍地址</span></div><div class="line"></div><div class="line">s.platform     = <span class="symbol">:ios</span>, <span class="string">'7.0'</span>            <span class="comment">#支持的平台及版本</span></div><div class="line">s.requires_arc = <span class="literal">true</span>                   <span class="comment">#是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span></div><div class="line"></div><div class="line">s.source_files = <span class="string">'Pod/Classes/**/*'</span>     <span class="comment">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></div><div class="line">s.resource_bundles = &#123;</div><div class="line"><span class="string">'PodTestLibrary'</span> =&gt; [<span class="string">'Pod/Assets/*.png'</span>]</div><div class="line">&#125;                                       <span class="comment">#资源文件地址</span></div><div class="line"></div><div class="line">s.public_header_files = <span class="string">'Pod/Classes/**/*.h'</span>   <span class="comment">#公开头文件地址</span></div><div class="line">s.frameworks = <span class="string">'UIKit'</span>                  <span class="comment">#所需的framework，多个用逗号隔开</span></div><div class="line">s.dependency <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.3'</span>   <span class="comment">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<h4 id="验证podspec文件可用性"><a href="#验证podspec文件可用性" class="headerlink" title="验证podspec文件可用性"></a>验证podspec文件可用性</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pod lib lint</div><div class="line"></div><div class="line">输出：</div><div class="line">-&gt; PodTestLibrary (<span class="number">0</span>.<span class="number">1.0</span>)</div><div class="line">PodTestLibrary passed validation.</div></pre></td></tr></table></figure>
<p>说明验证通过了，不过这只是这个<code>podspec文件</code>是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。</p>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>通过<code>Cocoapods</code>创建出来的目录本身就在本地的<code>Git</code>管理下，我们需要做的就是给它添加远端仓库，同样去<code>GitHub</code>或其他的Git服务提供商那里创建一个<code>私有的仓库</code>，拿到<code>SSH地址</code>，然后<code>cd</code>到<code>LogSwift</code>目录<br><figure class="highlight"><figcaption><span>添加到远程仓库</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git commit -s -m "Initial Commit of Library"</div><div class="line">$ git remote add origin https://coding.net/git/LogSwift.git   #添加远端仓库</div><div class="line">$ git push origin master        #提交到远端仓库</div></pre></td></tr></table></figure></p>
<h2 id="手动配置Pod私库项目支持：spec-create"><a href="#手动配置Pod私库项目支持：spec-create" class="headerlink" title="手动配置Pod私库项目支持：spec create"></a>手动配置Pod私库项目支持：spec create</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec create LogSwift git@coding.<span class="symbol">net:</span>wtlucky/LogSwift.git</div></pre></td></tr></table></figure>
<p>执行完之后，就创建了一个<code>podspec文件</code>，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令<code>pod lib lint</code>验证一下。</p>
<h2 id="创建新项目配置库的依赖，来检测本地podspec文件"><a href="#创建新项目配置库的依赖，来检测本地podspec文件" class="headerlink" title="创建新项目配置库的依赖，来检测本地podspec文件"></a>创建新项目配置库的依赖，来检测本地podspec文件</h2><p>在这个项目的<code>Podfile</code>文件中直接指定刚才创建编辑好的<code>podspec文件</code>，看是否可用。<br>有两种方式:<br><figure class="highlight ruby"><figcaption><span>Podfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></div><div class="line">pod <span class="string">'LogSwift'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'~/code/Cocoapods/podTest/LogSwift'</span>      <span class="comment"># 指定路径</span></div><div class="line">pod <span class="string">'LogSwift'</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">'~/code/Cocoapods/podTest/LogSwift/LogSwift.podspec'</span>  <span class="comment"># 指定podspec文件</span></div></pre></td></tr></table></figure><br>然后执行<code>pod install</code>命令安装依赖，打开项目工程，可以看到<code>库文件</code>和<code>资源</code>都被加载到<code>Pods子项目</code>中了，不过它们并没有在<code>Pods目录</code>下，而是跟测试项目一样存在于<code>Development Pods/LogSwift</code>中，这是因为我们是在本地测试，而没有把<code>podspec文件</code>添加到<code>Spec Repo</code>中的缘故。</p>
<h2 id="repo-push向私有索引库中提交podspec文件"><a href="#repo-push向私有索引库中提交podspec文件" class="headerlink" title="repo push向私有索引库中提交podspec文件"></a>repo push向私有索引库中提交podspec文件</h2><p><code>Spec Repo</code>即<code>pod repo add SpecReponame 托管库URL</code>时的<code>SpecReponame</code>。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod repo push LogSwift LogSwift.podspec  <span class="comment">#前面是本地Repo名字 后面是podspec名字</span></div></pre></td></tr></table></figure><br>在提交之前，务必保证在本地测试确保无误。<br>完成之后这个<code>组件库</code>就添加到<code>私有索引库</code>中了，会先在本地<code>~/.cocoapods/repos/LogSwift</code>目录下自动生成标准的<code>pod 库结构</code>，然后后并上传到远端的<code>LogSwift.git</code>仓库中。</p>
<h2 id="repo-trunk添加到Cocoapods的官方索引库"><a href="#repo-trunk添加到Cocoapods的官方索引库" class="headerlink" title="repo trunk添加到Cocoapods的官方索引库"></a>repo trunk添加到Cocoapods的官方索引库</h2><h2 id="使用远程的私有Pod库"><a href="#使用远程的私有Pod库" class="headerlink" title="使用远程的私有Pod库"></a>使用远程的私有Pod库</h2><p>我们的这个组件库就已经制作添加完成了，现在可以<code>pod search</code>命令查到这个库，当使用时配置Podfile依赖文件即可。</p>
<ol>
<li>pod search 查找库<figure class="highlight"><figcaption><span>查找库</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ pod search PodTestLibrary</div><div class="line"></div><div class="line">-&gt; PodTestLibrary (0.1.0)</div><div class="line">Just Testing.</div><div class="line">pod 'PodTestLibrary', '~&gt; 0.1.0'</div><div class="line">- Homepage: https://coding.net/u/wtlucky/p/podTestLibrary</div><div class="line">- Source:   https://coding.net/wtlucky/podTestLibrary.git</div><div class="line">- Versions: 0.1.0 [WTSpecs repo]</div></pre></td></tr></table></figure></li>
<li>在Podfile文件中配置库依赖<figure class="highlight ruby"><figcaption><span>配置库依赖</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod <span class="string">'PodTestLibrary'</span>, <span class="string">'~&gt; 0.1.0'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="更新维护podspec文件配置，升级库版本"><a href="#更新维护podspec文件配置，升级库版本" class="headerlink" title="更新维护podspec文件配置，升级库版本"></a>更新维护podspec文件配置，升级库版本</h2><p><code>subspec</code>特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括<code>工具类</code>，底层<code>Model</code>及<code>UIKit</code>扩展等。</p>
<h3 id="添加模块库文件和资源"><a href="#添加模块库文件和资源" class="headerlink" title="添加模块库文件和资源"></a>添加模块库文件和资源</h3><p>具体做法是先将源文件添加到<code>Pod/Classes</code>中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在<code>Pod/Classes</code>下有创建了四个子目录</p>
<h3 id="打tag号作为podspec版本号-1"><a href="#打tag号作为podspec版本号-1" class="headerlink" title="打tag号作为podspec版本号"></a>打tag号作为podspec版本号</h3><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class="highlight ruby"><figcaption><span>打标签</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -m <span class="string">"first release"</span> <span class="number">0</span>.<span class="number">1.0</span></div><div class="line">$ git push --tags     <span class="comment">#推送tag到远端仓库</span></div></pre></td></tr></table></figure></p>
<h3 id="更新podspec配置文件"><a href="#更新podspec配置文件" class="headerlink" title="更新podspec配置文件"></a>更新podspec配置文件</h3><p>当创建了<code>subspec</code>，之前项目整体的依赖<code>dependency</code>:</p>
<ol>
<li>源文件:<code>source_files</code></li>
<li>头文件:<code>public_header_files</code></li>
<li>资源文件:<code>resource</code><br>都移动到了各自的<code>subspec</code>中，每个<code>subspec</code>之间也可以有相互的依赖关系，比如<code>UIKitAdditio</code>n就依赖于<code>CommonTools</code>。<figure class="highlight ruby"><figcaption><span>更新podspec配置文件</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></div><div class="line">s.name             = <span class="string">"PodTestLibrary"</span></div><div class="line">s.version          = <span class="string">"1.0.0"</span></div><div class="line">s.summary          = <span class="string">"Just Testing."</span></div><div class="line">s.description      = <span class="string">&lt;&lt;-DESC</span></div><div class="line">                         Testing Private Podspec.</div><div class="line"></div><div class="line">                        * Markdown format.</div><div class="line">                        * Don't worry about the indent, we strip it!</div><div class="line">                    DESC</div><div class="line">s.homepage         = <span class="string">"https://coding.net/u/wtlucky/p/podTestLibrary"</span></div><div class="line"><span class="comment"># s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"</span></div><div class="line">s.license          = <span class="string">'MIT'</span></div><div class="line">s.author           = &#123; <span class="string">"wtlucky"</span> =&gt; <span class="string">"wtlucky@foxmail.com"</span> &#125;</div><div class="line">s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://coding.net/wtlucky/podTestLibrary.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"1.0.0"</span> &#125;</div><div class="line"><span class="comment"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></div><div class="line"></div><div class="line">s.platform     = <span class="symbol">:ios</span>, <span class="string">'7.0'</span></div><div class="line">s.requires_arc = <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#s.source_files = 'Pod/Classes/**/*'</span></div><div class="line"><span class="comment">#s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125;</span></div><div class="line"><span class="comment">#s.public_header_files = 'Pod/Classes/**/*.h'</span></div><div class="line"></div><div class="line">s.subspec <span class="string">'NetWorkEngine'</span> <span class="keyword">do</span> <span class="params">|networkEngine|</span></div><div class="line">    networkEngine.source_files = <span class="string">'Pod/Classes/NetworkEngine/**/*'</span></div><div class="line">    networkEngine.public_header_files = <span class="string">'Pod/Classes/NetworkEngine/**/*.h'</span></div><div class="line">    networkEngine.dependency <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.3'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">s.subspec <span class="string">'DataModel'</span> <span class="keyword">do</span> <span class="params">|dataModel|</span></div><div class="line">    dataModel.source_files = <span class="string">'Pod/Classes/DataModel/**/*'</span></div><div class="line">    dataModel.public_header_files = <span class="string">'Pod/Classes/DataModel/**/*.h'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">s.subspec <span class="string">'CommonTools'</span> <span class="keyword">do</span> <span class="params">|commonTools|</span></div><div class="line">    commonTools.source_files = <span class="string">'Pod/Classes/CommonTools/**/*'</span></div><div class="line">    commonTools.public_header_files = <span class="string">'Pod/Classes/CommonTools/**/*.h'</span></div><div class="line">    commonTools.dependency <span class="string">'OpenUDID'</span>, <span class="string">'~&gt; 1.0.0'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">s.subspec <span class="string">'UIKitAddition'</span> <span class="keyword">do</span> <span class="params">|ui|</span></div><div class="line">    ui.source_files = <span class="string">'Pod/Classes/UIKitAddition/**/*'</span></div><div class="line">    ui.public_header_files = <span class="string">'Pod/Classes/UIKitAddition/**/*.h'</span></div><div class="line">    ui.resource = <span class="string">"Pod/Assets/MLSUIKitResource.bundle"</span></div><div class="line">    ui.dependency <span class="string">'PodTestLibrary/CommonTools'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">s.frameworks = <span class="string">'UIKit'</span></div><div class="line">    <span class="comment">#s.dependency 'AFNetworking', '~&gt; 2.3'</span></div><div class="line">    <span class="comment">#s.dependency 'OpenUDID', '~&gt; 1.0.0'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
编辑完成之后，在测试项目里<code>pod update</code>一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的<code>tag-&gt;1.0.0</code>。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;repo-add命令添加自己的索引库&quot;&gt;&lt;a href=&quot;#repo-add命令添加自己的索引库&quot; class=&quot;headerlink&quot; title=&quot;repo add命令添加自己的索引库&quot;&gt;&lt;/a&gt;repo add命令添加自己的索引库&lt;/h2&gt;&lt;p&gt;在githu
    
    </summary>
    
      <category term="管理" scheme="https://huos3203.github.io/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="搭建" scheme="https://huos3203.github.io/tags/%E6%90%AD%E5%BB%BA/"/>
    
      <category term="管理" scheme="https://huos3203.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="pod" scheme="https://huos3203.github.io/tags/pod/"/>
    
      <category term="私库" scheme="https://huos3203.github.io/tags/%E7%A7%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>UIStackView教程：了解Stack View</title>
    <link href="https://huos3203.github.io/2017/02/24/UIStackView%E6%95%99%E7%A8%8B%E4%BA%86%E8%A7%A3StackView/"/>
    <id>https://huos3203.github.io/2017/02/24/UIStackView教程了解StackView/</id>
    <published>2017-02-24T10:12:14.000Z</published>
    <updated>2017-02-25T06:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/kmyhy/article/details/50456444" target="_blank" rel="external">原地址</a></p>
<h2 id="UIStackView简单介绍"><a href="#UIStackView简单介绍" class="headerlink" title="UIStackView简单介绍"></a>UIStackView简单介绍</h2><p>一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。。<br><img src="/images/stack0.png" width="450" height="300"><br>坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。<br>distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。<br>对于水平的Stack View，这个属性则稍有不同：<br><img src="/images/stack006.png" class="distribution/Alignment属性区别"><br>.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。<br>对于水平的Stack View，这个属性则稍有不同：<br>Fill:<br><img src="/images/stack007.png" class="Fill"><br>Leading:<br><img src="/images/stack008.png" class="Leading"><br>Center:<br><img src="/images/stack009.png" class="Center"><br>Trailing:<br><img src="/images/stack000.png" class="Trailing"></p>
<p>布局方式对比<br><img src="/images/stack01.png" class="布局方式对比"></p>
<h3 id="添加一个新的Stack-View"><a href="#添加一个新的Stack-View" class="headerlink" title="添加一个新的Stack View"></a>添加一个新的Stack View</h3><p>点击故事板画布左下角<code>Auto Layout工具栏</code>中的<code>Stack按钮</code>：<br><img src="/images/stack3.png" class="Stack按钮"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\Emebed in\stack view</code>菜单。</p>
<h3 id="解散一个废弃的Stack-View"><a href="#解散一个废弃的Stack-View" class="headerlink" title="解散一个废弃的Stack View"></a>解散一个废弃的Stack View</h3><p>首先，选定想解散的Stack View。按下<code>Option键</code>，点击<code>Stack 按钮</code>。这将弹出一个上下文菜单，然后点击Unembed：<br><img src="/images/stack001.png"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\Unemebed</code>菜单。</p>
<h2 id="使用场景描述"><a href="#使用场景描述" class="headerlink" title="使用场景描述"></a>使用场景描述</h2><p>当APP运行中增加或删除一个<code>view</code>时，需要重新调整邻近<code>view</code>的位置布局。<br>预见困境：</p>
<ol>
<li>在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束</li>
<li>使用第三方库来实现</li>
<li>根据任务复杂程度完全用代码实现<br>也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。</li>
</ol>
<p><code>UIStackView</code>提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。</p>
<h2 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h2><p>存在着这几方面的问题:</p>
<h3 id="问题一：自适应横竖屏"><a href="#问题一：自适应横竖屏" class="headerlink" title="问题一：自适应横竖屏"></a>问题一：自适应横竖屏</h3><p>在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用<code>UIStackView</code>来帮助实现自动适应横竖屏的效果。<br><img src="/images/UIStackView.png"></p>
<h3 id="问题二：控件间留白不紧凑"><a href="#问题二：控件间留白不紧凑" class="headerlink" title="问题二：控件间留白不紧凑"></a>问题二：控件间留白不紧凑</h3><p>点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。<br><img src="/images/WEATHERhide.png"></p>
<h3 id="Storyboard引入界面"><a href="#Storyboard引入界面" class="headerlink" title="Storyboard引入界面"></a>Storyboard引入界面</h3><p>打开<code>Main.storyboard</code>，找到<code>Spot Info View Controller</code>这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到<code>Stack View</code>属性的改变导致其内部视图的变化。<br><img src="/images/stack1.png"><br>如果想在运行App时看见这些颜色，在<code>SpotInfoViewController</code>的<code>viewDidLoad()</code>方法中将下列语句注释：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清空标签和按钮的背景色</span></div><div class="line"><span class="keyword">for</span> view <span class="keyword">in</span> backgroundColoredViews </div><div class="line">&#123;</div><div class="line">    view.backgroundColor = <span class="type">UIColor</span>.clearColor()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Size类便于使用storyboard"><a href="#Size类便于使用storyboard" class="headerlink" title="Size类便于使用storyboard"></a>Size类便于使用storyboard</h3><p>在本案例中，故事板中Scene大小不是默认<code>600x600</code>，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。<br><img src="/images/05-simulated-metrics-iphone-4-inch_639x173.png"></p>
<h2 id="创建水平UIStackView"><a href="#创建水平UIStackView" class="headerlink" title="创建水平UIStackView"></a>创建水平<code>UIStackView</code></h2><h3 id="按钮模块"><a href="#按钮模块" class="headerlink" title="按钮模块"></a>按钮模块</h3><ol>
<li>选中按钮<br>用<code>Command+左键</code>同时选中<code>Spot Info View Controller</code>底下一排的所有按钮：<img src="/images/stack2.png"></li>
<li>Stack按钮添加一个新的Stack View<br>点击故事板画布左下角<code>Auto Layout工具栏</code>中新增的<code>Stack按钮</code>：    </li>
</ol>
<img src="/images/stack3.png" class="Stack按钮">
<p>这些按钮被嵌到一个新的Stack View中：</p>
<img src="/images/stack4.png">
<h4 id="给新的Stack-View添加布局约束"><a href="#给新的Stack-View添加布局约束" class="headerlink" title="给新的Stack View添加布局约束"></a>给新的Stack View添加布局约束</h4><p>要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。<br>3.1 在<code>Outline视图</code>中选取Stack View</p>
<img src="/images/stack5.png" class="Outline视图">
<p>3.2 Shift+右键调出View树<br>在Stack View 的任意地方按下<code>Shift+右键</code>或者<code>Control+Shift+左键</code>（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。</p>
<img src="/images/stack6.png" class="Shift+右键:View树">
<ol>
<li>自动布局工具栏中的Pin按钮,添加一个约束<img src="/images/stack7.png" class="自动布局工具栏中的Pin按钮">
</li>
</ol>
<p>首先勾选Constrain to margins。然后在Stack View四周添加下列约束：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Top</span>: <span class="number">20</span>, <span class="type">Leading</span>: <span class="number">0</span>, <span class="type">Trailing</span>: <span class="number">0</span>, <span class="type">Bottom</span>: <span class="number">0</span></div></pre></td></tr></table></figure><br>仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：<br><img src="/images/stack8.png" class="Add 4 Constraints"></p>
<h4 id="按钮等间距分布"><a href="#按钮等间距分布" class="headerlink" title="按钮等间距分布"></a>按钮等间距分布</h4><p>添加约束后，导致第一个按钮被拉伸：<br><img src="/images/stack9.png" class="第一个按钮被拉伸填充所有剩余空间"></p>
<h5 id="使用等宽约束的Spacer-View实现"><a href="#使用等宽约束的Spacer-View实现" class="headerlink" title="使用等宽约束的Spacer View实现"></a>使用等宽约束的<code>Spacer View</code>实现</h5><p>解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。<br>这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：<br><img src="/images/stack04.png" class="`Spacer View`添加等宽约束实现"><br>如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。</p>
<h5 id="Distribution属性：沿轴向水平分布"><a href="#Distribution属性：沿轴向水平分布" class="headerlink" title="Distribution属性：沿轴向水平分布"></a><code>Distribution</code>属性：沿轴向水平分布</h5><p>distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>打开Stack View属性面板。将<code>Distribution</code>属性由<code>Fill</code>修改为<code>Equal Spacing</code>：<br><img src="/images/stack02.png" class="`Fill`修改为`Equal Spacing`"><br>编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！<br><img src="/images/stack03.png" class="`Distribution`属性值`Equal Spacing`"></p>
<h3 id="Rating版块"><a href="#Rating版块" class="headerlink" title="Rating版块"></a>Rating版块</h3><p>选中RATING标签，以及旁边的显示为几个星形图标的标签：<br><img src="/images/stack05.png" class="选中RATING标签"><br>然后点击Stack按钮将它们嵌到一个Stack View中：<br><img src="/images/stack3.png" class="Stack按钮"><br><img src="/images/stack06.png" class="RATING标签嵌到一个Stack View中"><br>然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Top</span>: <span class="number">20</span>, <span class="type">Leading</span>: <span class="number">0</span>, <span class="type">Bottom</span>: <span class="number">20</span></div></pre></td></tr></table></figure><br><img src="/images/stack07.png" class="添加约束"><br>打开属性面板，将间距设置为8：<br><img src="/images/stack08.png" class="间距设置为8"><br>你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：<br><img src="/images/stack09.png" class="Misplaced Views的布局约束警告"><br>有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。<br>要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。<br>让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：<br><img src="/images/stack00.png" class="布局约束警告消失"><br>编译运行，进行测试</p>
<h2 id="创建垂直的Stack-View"><a href="#创建垂直的Stack-View" class="headerlink" title="创建垂直的Stack View"></a>创建垂直的Stack View</h2><p>Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。</p>
<h3 id="WHY-VISIT模块"><a href="#WHY-VISIT模块" class="headerlink" title="WHY VISIT模块"></a>WHY VISIT模块</h3><p>选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：<br><img src="/images/stack002.png" class="选中WHY VISIT标签及下面的标签"><br>点击Stack 按钮将二者嵌到一个Stack View：<br><img src="/images/stack003.png" class="嵌到一个垂直的Stack View"></p>
<h4 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h4><p>默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。<br>选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。<br>然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：<br><img src="/images/stack004.png" class="Top、Leading、Trainling为0"><br>最后点击Add 4 Constraints按钮。显示结果如下图所示：<br><img src="/images/stack005.png" class="Top、Leading、Trainling为0"></p>
<h4 id="alignment属性：轴向的垂直方向"><a href="#alignment属性：轴向的垂直方向" class="headerlink" title="alignment属性：轴向的垂直方向"></a>alignment属性：轴向的垂直方向</h4><p>Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。<br>当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：<br><img src="/images/stack0001.png" class="Top、Leading、Trainling为0"><br>将<code>Alignment</code>设置为<code>Fill</code>，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.</p>
<p>如果我们只想让底下的标签将宽度扩展到100%怎么办？</p>
<p>这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。</p>
<p>我们将用另外一个Stack View来说明这个问题。</p>
<h2 id="垂直／水平Stack-View嵌套使用"><a href="#垂直／水平Stack-View嵌套使用" class="headerlink" title="垂直／水平Stack View嵌套使用"></a>垂直／水平Stack View嵌套使用</h2><h3 id="Weather版块"><a href="#Weather版块" class="headerlink" title="Weather版块"></a>Weather版块</h3><p>在Weather版块相对复杂一些，因为它多了一个Hide按钮。<br>要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。<br>一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。<br><img src="/images/stack0002.png" class="垂直／水平Stack View嵌套使用"></p>
<h4 id="垂直stackView"><a href="#垂直stackView" class="headerlink" title="垂直stackView"></a>垂直stackView</h4><p>注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：<br><img src="/images/stack0003.png" class="垂直／水平Stack View嵌套使用"></p>
<h4 id="水平StackView中出现按钮拉伸标签的问题"><a href="#水平StackView中出现按钮拉伸标签的问题" class="headerlink" title="水平StackView中出现按钮拉伸标签的问题"></a>水平StackView中出现按钮拉伸标签的问题</h4><p>注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。<br>正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。<br>这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！</p>
<h4 id="垂直stack-View1-嵌套WEATHER标签和标签"><a href="#垂直stack-View1-嵌套WEATHER标签和标签" class="headerlink" title="垂直stack View1:嵌套WEATHER标签和标签"></a>垂直stack View1:嵌套WEATHER标签和标签</h4><p>选中WEATHER标签和标签：<br><img src="/images/stack0004.png" class="选中嵌套标签"><br>点击 Stack 按钮：<br><img src="/images/stack0005.png" class="Stack 按钮创建stackView"><br>点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Top</span>: <span class="number">20</span>, <span class="type">Leading</span>: <span class="number">0</span>, <span class="type">Trailing</span>: <span class="number">0</span>, <span class="type">Bottom</span>: <span class="number">20</span></div></pre></td></tr></table></figure><br>将Stack View的Alignment设为Fill：<br><img src="/images/stack0006.png" class="Alignment设为Fill"><br>我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。</p>
<p>当然，底下的标签宽度还是需要100%占满的。</p>
<p>我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。</p>
<h4 id="垂直stack-View2-仅嵌套WEATHER标签"><a href="#垂直stack-View2-仅嵌套WEATHER标签" class="headerlink" title="垂直stack View2: 仅嵌套WEATHER标签"></a>垂直stack View2: 仅嵌套WEATHER标签</h4><p>从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：<br><img src="/images/stack0006.png" class="Stack 按钮创建stackView"><br>然后点击Stack 按钮：<br><img src="/images/stack0007.png" class="Stack 按钮创建stackView"><br>确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：<br><img src="/images/stack0008.png" class="Alignment设置为Leading"></p>
<h4 id="按钮和WEATHER标签两个约束"><a href="#按钮和WEATHER标签两个约束" class="headerlink" title="按钮和WEATHER标签两个约束"></a>按钮和WEATHER标签两个约束</h4><p>从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：<br><img src="/images/stack0009.png" class="Add Constraints"><br>按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img src="/images/stack0000.png" class="Add Constraints"><br>编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。<br><img src="/images/stack010.png" class="编译运行"></p>
<h2 id="顶级-Stack-View"><a href="#顶级-Stack-View" class="headerlink" title="顶级 Stack View"></a>顶级 Stack View</h2><p>在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：<br><img src="/images/stack011.png" class="选中视图"><br>然后点击 Stack 按钮：<br><img src="/images/stack012.png" class="Stack 按钮"><br>点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：<br><img src="/images/stack013.png" class="添加约束"><br>编译运行：<br><img src="/images/stack014.png" class="编译运行"><br>噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。</p>
<p>右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img src="/images/stack015.png" class="Add Constraints"></p>
<h2 id="重新调整视图位置"><a href="#重新调整视图位置" class="headerlink" title="重新调整视图位置"></a>重新调整视图位置</h2><p>现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。</p>
<p>从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。<br>注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：<br><img src="/images/stack016.png" class="调整视图位置"></p>
<p>现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。</p>
<p>点击 Hide 按钮，选中它：<br><img src="/images/stack017.png" class="Hide 按钮"></p>
<p>然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：<br><img src="/images/stack018.png" class="Update Hide 按钮 Frames"><br>现在 Hide 按钮将回到正确的位置：<br><img src="/images/stack019.png" class="Update Hide 按钮 Frames"></p>
<h2 id="基于配置的-Size-类"><a href="#基于配置的-Size-类" class="headerlink" title="基于配置的 Size 类"></a>基于配置的 Size 类</h2><p>最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.</p>
<p>选择顶层 Stack View，点击 Spacing 前面的 + 按钮：<br><img src="/images/stack020.png" class="Spacing 前面的 + 按钮"></p>
<p>选择 Any Width &gt; Compact Height：<br><img src="/images/stack021.png" class="Compact Height"></p>
<p>在新出现的 wAny hC 一栏中，将 Spacing 设为 10：<br><img src="/images/stack022.png" class="Spacing 设为 10"><br>编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：<br><img src="/images/stack023.png" class="编译运行"><br>如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。</p>
<p>Stack View完全支持 <code>UIView 动画</code>。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。</p>
<p>让我们来看看代码怎么实现。打开 <code>SpotInfoViewController.Swift</code>，找到<br><code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>方法。</p>
<p>将方法的最后一行：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weatherInfoLabel.hidden = shouldHideWeatherInfo</div></pre></td></tr></table></figure><br>替换为：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> animated </div><div class="line">&#123;</div><div class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.3</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"><span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line">    weatherInfoLabel.hidden = shouldHideWeatherInfo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？</p>
<p>除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。<br><a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip" target="_blank" rel="external">开始项目源码</a><br><a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip" target="_blank" rel="external">完整项目源码</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/kmyhy/article/details/50456444&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;UIStackView简单介绍&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="iOS" scheme="https://huos3203.github.io/categories/iOS/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="UI" scheme="https://huos3203.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>CFBundleDisplayName更改APP启动图标的名称</title>
    <link href="https://huos3203.github.io/2017/02/24/%E6%9B%B4%E6%94%B9%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E4%B8%8B%E6%96%B9%E7%9A%84%E5%90%8D%E7%A7%B0/"/>
    <id>https://huos3203.github.io/2017/02/24/更改设备屏幕上显示的应用程序图标下方的名称/</id>
    <published>2017-02-24T06:23:59.000Z</published>
    <updated>2017-02-24T06:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>修改APP启动图标上的名称，需配置<code>Info.plist</code>文件，增加<code>CFBundleDisplayName</code>属性键值对。<br>进入到如下界面：<br><!--长宽设置百分比大小无效果--><br><img src="/images/qa1823_ExpandAppInProjectNavigator.png"></p>
<p>在<code>Info.plist</code>文件属性列表中搜索”Bundle display name”，如果存在就修改为新APP名称。<br>如果不存在，在任何一个属性条目下，点击”+”按钮，弹出的下拉列表中选择”Bundle display name”，再双击”Bundle display name”属性值列，输入新APP名称。<br><!--长宽设置百分比大小无效果--><br><img src="/images/qa1823_WatchKitAppInfoPane.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改APP启动图标上的名称，需配置&lt;code&gt;Info.plist&lt;/code&gt;文件，增加&lt;code&gt;CFBundleDisplayName&lt;/code&gt;属性键值对。&lt;br&gt;进入到如下界面：&lt;br&gt;&lt;!--长宽设置百分比大小无效果--&gt;&lt;br&gt;&lt;img src=&quot;/imag
    
    </summary>
    
      <category term="macOS" scheme="https://huos3203.github.io/categories/macOS/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="经历" scheme="https://huos3203.github.io/tags/%E7%BB%8F%E5%8E%86/"/>
    
      <category term="配置" scheme="https://huos3203.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>高期望实现异步单元测试</title>
    <link href="https://huos3203.github.io/2017/02/20/%E9%AB%98%E6%9C%9F%E6%9C%9B%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://huos3203.github.io/2017/02/20/高期望实现异步单元测试/</id>
    <published>2017-02-20T15:09:30.000Z</published>
    <updated>2017-02-20T15:24:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步单元测试"><a href="#异步单元测试" class="headerlink" title="异步单元测试"></a>异步单元测试</h2><p>在Xcode 6之前的版本里面并没有内置<code>XCTest</code>，只能是在主线程的<code>RunLoop</code>里面使用一个<code>while循环</code>,然后一直等待响应或者直到<code>timeout</code>.</p>
<p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。<br>XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>
<h3 id="常规实现方式"><a href="#常规实现方式" class="headerlink" title="常规实现方式"></a>常规实现方式</h3><p>在主线程里，使用<code>while循环</code>每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func testAsyncTheOldWay()</div><div class="line">&#123;</div><div class="line">    let timeoutDate = Date.init(timeIntervalSinceNow: 5.0)</div><div class="line">    var responseHasArrived = false</div><div class="line">    Alamofire.request("https://www.baidu.com").responseData&#123;response in</div><div class="line">        print("获取到的数据长度：\(String(data: response.data!, </div><div class="line">                                   encoding:String.Encoding.utf8)!)")</div><div class="line">        responseHasArrived = true</div><div class="line">        XCTAssert((response.data?.count)! &gt; 0)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (responseHasArrived == false </div><div class="line">            &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; 0)) </div><div class="line">    &#123;</div><div class="line">        CFRunLoopRunInMode(CFRunLoopMode.defaultMode, 0.01, false)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (responseHasArrived == false)</div><div class="line">    &#123;</div><div class="line">        XCTFail("Test timed out")</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="XCTest相关API"><a href="#XCTest相关API" class="headerlink" title="XCTest相关API"></a>XCTest相关API</h2><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。</p>
<h3 id="XCTestExpection-高期望-High-Expectations-的实现和使用"><a href="#XCTestExpection-高期望-High-Expectations-的实现和使用" class="headerlink" title="XCTestExpection:高期望(High Expectations)的实现和使用"></a>XCTestExpection:高期望(High Expectations)的实现和使用</h3><p>设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>
<h4 id="expectation-description-为XCTest测试单元设置期望"><a href="#expectation-description-为XCTest测试单元设置期望" class="headerlink" title="expectation(description:):为XCTest测试单元设置期望"></a><code>expectation(description:)</code>:为XCTest测试单元设置期望</h4><p>为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻<code>fulfill</code>实现该期望对象<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//expectation(description: String) -&gt; XCTestExpectation</span></div><div class="line"><span class="keyword">let</span> expection = expectation(description: <span class="string">"失败时显示原因"</span>)</div></pre></td></tr></table></figure></p>
<h5 id="fulfill-调用它表示测试达到期望值"><a href="#fulfill-调用它表示测试达到期望值" class="headerlink" title="fulfill():调用它表示测试达到期望值"></a><code>fulfill()</code>:调用它表示测试达到期望值</h5><p>一般在单元测试通过时调用，告知测试已达期望，这一方法替代了<code>responseHasArrived</code>作为Flag的方式<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//- (void)fulfill;</span></div><div class="line">expection.fulfill()</div></pre></td></tr></table></figure></p>
<h4 id="waitForExpectations-timeout-handler-在方法底部设置测试期望的时效"><a href="#waitForExpectations-timeout-handler-在方法底部设置测试期望的时效" class="headerlink" title="waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效"></a><code>waitForExpectations(timeout:handler:)</code>:在方法底部设置测试期望的时效</h4><p>在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)</span></div><div class="line">waitForExpectations(timeout: <span class="number">5</span>) &#123; error <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"错误信息:\(error?.localizedDescription)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果完成处理的代码在指定时限里执行并调用了<code>fulfill()</code>方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行</p>
<h4 id="expectation-forNotification-object-handler-通知期望"><a href="#expectation-forNotification-object-handler-通知期望" class="headerlink" title="expectation(forNotification:object:handler:):通知期望"></a>expectation(forNotification:object:handler:):通知期望</h4><p>该方法监听一个通知,如果在规定时间内正确收到通知则测试通过<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation</span></div><div class="line"><span class="comment">//设置一个测试通知期望</span></div><div class="line">expectation(forNotification: <span class="string">"BLDownloadImageNotification"</span>, </div><div class="line">                     object: <span class="literal">nil</span>) </div><div class="line">&#123;(notification) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> userInfo = notification.userInfo <span class="keyword">as</span>! [<span class="type">String</span>:<span class="type">String</span>]</div><div class="line">    <span class="keyword">let</span> name = userInfo[<span class="string">"name"</span>]</div><div class="line">    <span class="built_in">print</span>(<span class="string">"name:\(name)"</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line">来定义一个通知并发送通知，来测试：</div><div class="line"><span class="keyword">let</span> notif =  <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"BLDownloadImageNotification"</span>)</div><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notif, object: <span class="keyword">self</span>, userInfo: [<span class="string">"name"</span>:<span class="string">"huosan"</span>,<span class="string">"sex"</span>:<span class="string">"man"</span>])</div><div class="line"></div><div class="line"><span class="comment">//设置延迟多少秒后，如果没有满足测试条件就报错</span></div><div class="line">waitForExpectations(timeout: <span class="number">3</span>, handler: <span class="literal">nil</span>)</div></pre></td></tr></table></figure></p>
<h5 id="使用expectation-description-实现"><a href="#使用expectation-description-实现" class="headerlink" title="使用expectation(description:)实现"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(forNotification:object:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAsynForNotificationWithExpectation</span><span class="params">()</span></span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> expectation = <span class="keyword">self</span>.expectation(description: <span class="string">"BLDownloadImageNotification"</span>)</div><div class="line">    <span class="keyword">let</span> notif = <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"BLDownloadImageNotification"</span>)</div><div class="line">    <span class="keyword">let</span> sub = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: notif, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; (notification) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">        expectation.fulfill()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//发送一个通知</span></div><div class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notif, object: <span class="literal">nil</span>)</div><div class="line">    </div><div class="line">    <span class="comment">//waitForExpectations</span></div><div class="line">    waitForExpectations(timeout: <span class="number">1</span>, handler: <span class="literal">nil</span>)</div><div class="line">    </div><div class="line">    <span class="comment">//移除通知</span></div><div class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(sub)</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<h4 id="expectation-for-evaluatedWith-handler-谓词计算测试法"><a href="#expectation-for-evaluatedWith-handler-谓词计算测试法" class="headerlink" title="expectation(for:evaluatedWith:handler:):谓词计算测试法"></a>expectation(for:evaluatedWith:handler:):谓词计算测试法</h4><p>利用谓词计算，判断<code>button</code>的<code>backgroundImageForState</code>方法，是否正确的获得了<code>backgroundImage</code>，如果<code>20秒</code>内正确获得则通过测试，否则失败<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectation</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testThatBackgroundImageChanges</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> viewController = <span class="type">OnclickLikeViewController</span>()</div><div class="line">    <span class="comment">//viewController.loadView()  //不执行viewDidload方法</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = viewController.view</div><div class="line">    <span class="keyword">let</span> button = viewController.button</div><div class="line">    <span class="keyword">let</span> img = button.backgroundImage(<span class="keyword">for</span>: .normal)</div><div class="line">    <span class="type">XCTAssertNil</span>(img,<span class="string">"此时img不为nil,中止执行"</span>)  <span class="comment">//当img不是nil时，执行断言</span></div><div class="line">    <span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>.<span class="keyword">init</span> &#123; (anyobject, bindings) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">let</span> button = anyobject <span class="keyword">as</span>! <span class="type">UIButton</span></div><div class="line">        <span class="keyword">return</span> button.backgroundImage(<span class="keyword">for</span>: <span class="type">UIControlState</span>()) != <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    expectation(<span class="keyword">for</span>: predicate, evaluatedWith: button, handler: <span class="literal">nil</span>)</div><div class="line">    waitForExpectations(timeout: <span class="number">20</span>, handler: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="使用expectation-description-实现-1"><a href="#使用expectation-description-实现-1" class="headerlink" title="使用expectation(description:)实现"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(for:evaluatedWith:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testThatBackgroundImageChanges</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//设置期望</span></div><div class="line">    <span class="keyword">let</span> expectation = <span class="keyword">self</span>.expectation(description: <span class="string">"backgroundImageForState"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">let</span> viewController = <span class="type">OnclickLikeViewController</span>()</div><div class="line">    <span class="comment">//viewController.loadView()  //不执行viewDidload方法</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = viewController.view</div><div class="line">    <span class="keyword">let</span> button = viewController.button</div><div class="line">    <span class="keyword">let</span> img = button.backgroundImage(<span class="keyword">for</span>: .normal)</div><div class="line">    <span class="type">XCTAssertNil</span>(img,<span class="string">"此时img不为nil,中止执行"</span>)  <span class="comment">//当img不是nil时，执行断言</span></div><div class="line">    <span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>.<span class="keyword">init</span> &#123; (anyobject, bindings) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">let</span> button = anyobject <span class="keyword">as</span>! <span class="type">UIButton</span></div><div class="line">        <span class="keyword">return</span> button.backgroundImage(<span class="keyword">for</span>: <span class="type">UIControlState</span>()) != <span class="literal">nil</span></div><div class="line">        <span class="comment">//实现测试期望</span></div><div class="line">        expectation.fulfill()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//等待期望实现</span></div><div class="line">    waitForExpectations(timeout: <span class="number">20</span>, handler: <span class="literal">nil</span>)</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="传递expectation在目的方法中再fulfill-实现期望"><a href="#传递expectation在目的方法中再fulfill-实现期望" class="headerlink" title="传递expectation在目的方法中再fulfill()实现期望"></a>传递expectation在目的方法中再fulfill()实现期望</h3><p>例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的<code>fulfill()</code>方法，实现单元测试的期望<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAsynForNotificationWithExpectation2</span><span class="params">()</span></span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> expectation = <span class="keyword">self</span>.expectation(description: <span class="string">"BLDownloadImageNotification"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">let</span> notif = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"BLDownloadImageNotification"</span>)</div><div class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(<span class="type">AsyncTheOldWayTest</span>.downLoadImage(<span class="number">_</span>:)), name: notif, object: <span class="literal">nil</span>)</div><div class="line"></div><div class="line">        <span class="comment">//将期望封装在字典中传递</span></div><div class="line">        <span class="keyword">let</span> userInf = [<span class="string">"name"</span>:<span class="string">"huosan"</span>,<span class="string">"sex"</span>:<span class="string">"man"</span>,<span class="string">"expectation"</span>:expectation]</div><div class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notif, object: <span class="keyword">self</span>, userInfo: userInf)</div><div class="line">        <span class="comment">//等待期望实现</span></div><div class="line">        waitForExpectations(timeout: <span class="number">1</span>, handler: <span class="literal">nil</span>)</div><div class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">downLoadImage</span><span class="params">(<span class="number">_</span> notification:Notification)</span></span> </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">let</span> userInfo = notification.userInfo <span class="keyword">as</span>! [<span class="type">String</span>:<span class="type">AnyObject</span>]</div><div class="line">        <span class="keyword">let</span> name = userInfo[<span class="string">"name"</span>]</div><div class="line">        <span class="keyword">let</span> sex = userInfo[<span class="string">"sex"</span>]</div><div class="line">        <span class="built_in">print</span>(<span class="string">"name:\(name), sex = \(sex)"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">let</span> expectation = userInfo[<span class="string">"expectation"</span>] <span class="keyword">as</span>! <span class="type">XCTestExpectation</span></div><div class="line">        expectation.fulfill()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异步单元测试&quot;&gt;&lt;a href=&quot;#异步单元测试&quot; class=&quot;headerlink&quot; title=&quot;异步单元测试&quot;&gt;&lt;/a&gt;异步单元测试&lt;/h2&gt;&lt;p&gt;在Xcode 6之前的版本里面并没有内置&lt;code&gt;XCTest&lt;/code&gt;，只能是在主线程的&lt;code&gt;
    
    </summary>
    
      <category term="测试" scheme="https://huos3203.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="测试" scheme="https://huos3203.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="UI" scheme="https://huos3203.github.io/tags/UI/"/>
    
      <category term="单元测试" scheme="https://huos3203.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>UI自动测试开发相关API</title>
    <link href="https://huos3203.github.io/2017/02/20/UI%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://huos3203.github.io/2017/02/20/UI自动测试学习/</id>
    <published>2017-02-20T09:16:49.000Z</published>
    <updated>2017-02-24T06:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI-Testing-和-Accessibility"><a href="#UI-Testing-和-Accessibility" class="headerlink" title="UI Testing 和 Accessibility"></a>UI Testing 和 Accessibility</h2><p>UI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。</p>
<p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。</p>
<h2 id="UI-Testing-API"><a href="#UI-Testing-API" class="headerlink" title="UI Testing API"></a>UI Testing API</h2><h3 id="XCUIApplication-获取APP实例"><a href="#XCUIApplication-获取APP实例" class="headerlink" title="XCUIApplication()获取APP实例"></a>XCUIApplication()获取APP实例</h3><p><code>XCUIApplication()</code>继承<code>XCUIElement</code>，这个类掌管应用程序的生命周期，里面包含两个主要方法<br><code>launch():</code>启动程序<br><code>terminate():</code>终止程序</p>
<h3 id="获取XCUIElementQuery对象的四种方式"><a href="#获取XCUIElementQuery对象的四种方式" class="headerlink" title="获取XCUIElementQuery对象的四种方式"></a>获取<code>XCUIElementQuery</code>对象的四种方式</h3><h4 id="第一种简写形式：buttons-gt-XCUIElementQuery"><a href="#第一种简写形式：buttons-gt-XCUIElementQuery" class="headerlink" title="第一种简写形式：buttons-&gt;XCUIElementQuery"></a>第一种简写形式：<code>buttons-&gt;XCUIElementQuery</code></h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().buttons</div><div class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().textFields</div></pre></td></tr></table></figure>
<h4 id="三种通过XCUIElementType的枚举值"><a href="#三种通过XCUIElementType的枚举值" class="headerlink" title="三种通过XCUIElementType的枚举值"></a>三种通过<code>XCUIElementType</code>的枚举值</h4><p>通过<code>XCUIElementType</code>的枚举值来获取<code>XCUIElementQuery</code>对象，其中第二种是简写方式。<br><code>XCUIElementType</code>枚举声明如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">XCUIElementType</span> : <span class="title">UInt</span> </span></div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">case</span> button</div><div class="line">    <span class="keyword">case</span> radioButton</div><div class="line">    <span class="keyword">case</span> textField</div><div class="line">    <span class="keyword">case</span> comboBox</div><div class="line">    <span class="keyword">case</span> menuButton</div><div class="line">    <span class="keyword">case</span> toolbarButton</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery"><a href="#第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery" class="headerlink" title="第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery"></a>第一种获取所有的元素：<code>descendantsMatchingType-&gt;XCUIElementQuery</code></h5><p>取某种类型的元素以及它的子类集合，能获取到系统级控件如<code>UIButton</code>，和用户自定义的UI控件<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().descendantsMatchingType(.<span class="type">Button</span>)</div><div class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().descendantsMatchingType(.textField)</div></pre></td></tr></table></figure></p>
<h5 id="第三种仅获取当前层级子元素：childrenMatchingType"><a href="#第三种仅获取当前层级子元素：childrenMatchingType" class="headerlink" title="第三种仅获取当前层级子元素：childrenMatchingType"></a>第三种仅获取当前层级子元素：<code>childrenMatchingType</code></h5><p>取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如<code>UIButton</code>，不获取用户自定义的UI控件<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().childrenMatchingType(.<span class="type">Button</span>)</div><div class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().childrenMatchingType(.textField)</div></pre></td></tr></table></figure></p>
<h5 id="第四种所有包含的元素：containingType"><a href="#第四种所有包含的元素：containingType" class="headerlink" title="第四种所有包含的元素：containingType"></a>第四种所有包含的元素：<code>containingType</code></h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().containingType(.<span class="type">Button</span>)</div><div class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().containingType(.textField)</div></pre></td></tr></table></figure>
<h3 id="XCUIElement表示系统的各种UI控件"><a href="#XCUIElement表示系统的各种UI控件" class="headerlink" title="XCUIElement表示系统的各种UI控件"></a>XCUIElement表示系统的各种UI控件</h3><p><code>XCUIElement</code>UI控件在测试框架中的代理，继承<code>NSObject</code>，实现<code>XCUIElementAttributes</code>协议, <code>XCUIElementTypeQueryProvider</code>协议，可以表示系统的各种UI控件。</p>
<ol>
<li>XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性<img src="/images/XCUIElementAttributes.png">
<img src="/images/UIAccessibility.jpg"></li>
<li>XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合<img src="/images/XCUIElementTypeQueryProvider.png">
</li>
</ol>
<h4 id="访问UI控件"><a href="#访问UI控件" class="headerlink" title="访问UI控件"></a>访问UI控件</h4><ol>
<li><code>exist:</code>判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试.</li>
<li><code>element()</code>／<code>下标方法</code>：<code>XCUIElementQuery</code>实例的方法获取UI控件，不能直接通过<code>XCUIElement</code> 来访问 app 中的元素，只能通过 <code>Accessibility</code> 中的像是 <code>identifier</code> 或者 <code>frame</code> 这样的属性来获取 UI 的信息。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> userNameTextField:<span class="type">XCUIElement</span> = app.textFields.element(boundBy: <span class="number">0</span>)</div><div class="line"><span class="keyword">let</span> userNameTextField:<span class="type">XCUIElement</span> = app.textFields[<span class="string">"username"</span>]</div></pre></td></tr></table></figure>
对于 <code>XCUIElementQuery</code>，<code>Query</code>的执行是有延迟的，它和最后我们得到的 <code>XCUIElement</code> 并不是一一对应的。和 <code>NSURL</code> 与请求到的内容的关系类似，随着时间的变化，同一个 <code>URL</code> 有可能请求到不同的内容。<br>在拿到<code>Query</code>实例后，只有在通过<code>下标</code>或<code>访问方法</code>访问时，才会真正寻找对应的 <code>UI 控件</code>。这就是说，随着我们的 UI 的变化，同样的 <code>query</code> 也可能获取到不用的<code>UI控件</code>。为了获取UI元素准确：我们可以通过在 <code>Interface Builder</code> 或者<code>代码</code>中，对UI控件的 <code>identifier</code>属性进行设置，这样就可以使用下标的方式进行访问了。</li>
</ol>
<h4 id="设置UI控件触发事件和属性值"><a href="#设置UI控件触发事件和属性值" class="headerlink" title="设置UI控件触发事件和属性值"></a>设置UI控件<code>触发事件</code>和<code>属性值</code></h4><p>使用<code>typeText(text:String)</code>,<code>tap()</code>,<code>doubleTap()</code>等方法。<br>以获取userNameTextField控件为例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> userNameTextField:<span class="type">XCUIElement</span> = app.textFields.element(boundBy: <span class="number">0</span>)</div><div class="line">userNameTextField.tap()</div><div class="line">userNameTextField.typeText(<span class="string">"文本内容"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="XCUIElementAttributes协议"><a href="#XCUIElementAttributes协议" class="headerlink" title="XCUIElementAttributes协议"></a>XCUIElementAttributes协议</h4><p>UI元素中包含的各个属性，<code>identifier</code>，<code>frame</code>,<code>title</code>,<code>label</code>等…</p>
<ol>
<li>使用: 可使用这些属性来获取UI元素对象。<figure class="highlight swift"><figcaption><span>title获取</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> username = <span class="string">"hsg"</span></div><div class="line">userNameTextField.typeText(username)</div><div class="line">app.textFields[username].tap()</div></pre></td></tr></table></figure>
<figure class="highlight swift"><figcaption><span>identifier获取</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> identifier = <span class="string">"hsg"</span></div><div class="line">userNameTextField.typeText(username)</div><div class="line">app.textFields[username].tap()</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UI-Testing-和-Accessibility&quot;&gt;&lt;a href=&quot;#UI-Testing-和-Accessibility&quot; class=&quot;headerlink&quot; title=&quot;UI Testing 和 Accessibility&quot;&gt;&lt;/a&gt;UI Testi
    
    </summary>
    
      <category term="测试" scheme="https://huos3203.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="测试" scheme="https://huos3203.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="UI" scheme="https://huos3203.github.io/tags/UI/"/>
    
      <category term="单元测试" scheme="https://huos3203.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>通过转场动画代理协议自定义来展示型控制器</title>
    <link href="https://huos3203.github.io/2017/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%95%E7%A4%BA%E5%9E%8B%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>https://huos3203.github.io/2017/02/17/自定义展示型控制器/</id>
    <published>2017-02-17T04:26:11.000Z</published>
    <updated>2017-02-25T06:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="触发转场的方式"><a href="#触发转场的方式" class="headerlink" title="触发转场的方式"></a>触发转场的方式</h2><h3 id="官方支持的自定义转场"><a href="#官方支持的自定义转场" class="headerlink" title="官方支持的自定义转场"></a>官方支持的自定义转场</h3><ul>
<li>在 <code>UINavigationController</code> 中 <code>push</code> 和 <code>pop</code>;</li>
<li>在 <code>UITabBarController</code> 中切换 <code>Tab</code>;</li>
<li>Modal 转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;<br><code>UICollectionViewController</code> 的布局转场：仅限于 <code>UICollectionViewController</code> 与 <code>UINavigationController</code> 结合的转场方式，与上面三种都有点不同，不过实现很简单，可跳转至该链接查看。<br>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。<h3 id="相关触发转场的动作"><a href="#相关触发转场的动作" class="headerlink" title="相关触发转场的动作"></a>相关触发转场的动作</h3><h4 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h4><code>UINavigationController</code> 中所有修改其<code>viewControllers</code>栈中 <code>VC</code> 的方法都可以自定义转场动画：<figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我们使用的最广泛的 push 和 pop 方法</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pushViewController</span><span class="params">(<span class="number">_</span> viewController: UIViewController, animated animated: Bool)</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">popViewControllerAnimated</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> -&gt; <span class="type">UIViewController</span>?</div><div class="line"><span class="comment">//不怎么常用的 pop 方法</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">popToRootViewControllerAnimated</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]?</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">popToRootViewControllerAnimated</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]?</div><div class="line"><span class="comment">//这个方法有有点特别，是对 VC 栈的整体更新，开启动画后的执行比较复杂，具体参考文档说明。不建议在这种情况下开启转场动画。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setViewControllers</span><span class="params">(<span class="number">_</span> viewControllers: [UIViewController], animated animated: Bool)</span></span></div></pre></td></tr></table></figure>
<h4 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h4><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意传递的参数必须是其下的子 VC</span></div><div class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">var</span> selectedViewController: <span class="type">UIViewController</span>?</div><div class="line"><span class="keyword">var</span> selectedIndex: <span class="type">Int</span></div><div class="line"><span class="comment">//和上面类似的整体更新</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setViewControllers</span><span class="params">(<span class="number">_</span> viewControllers: [UIViewController]?, animated animated: Bool)</span></span></div></pre></td></tr></table></figure>
<h4 id="Modal-转场："><a href="#Modal-转场：" class="headerlink" title="Modal 转场："></a>Modal 转场：</h4><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Presentation 转场</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentViewController</span><span class="params">(<span class="number">_</span> viewControllerToPresent: UIViewController, animated flag: Bool, completion completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?)</div><div class="line"><span class="comment">// Dismissal 转场</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissViewControllerAnimated</span><span class="params">(<span class="number">_</span> flag: Bool, completion completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?)</div></pre></td></tr></table></figure>
<h4 id="Segue"><a href="#Segue" class="headerlink" title="Segue"></a>Segue</h4>在 <code>storyboard</code> 里设置 <code>segue</code>有两种方式：<code>Button to VC</code>，这种在点击 <code>Button</code> 的时候触发转场；<code>VC to VC</code>，这种需要在代码中调用<code>performSegueWithIdentifier:sender:</code>。<code>prepareForSegue:sender:</code>方法是在转场发生前修改转场参数的最后机会。这点对于 <code>Modal</code> 转场比较重要，因为在 <code>storyboard</code>里 <code>Modal</code> 转场的 <code>Segue</code> 类型不支持选择 <code>Custom</code> 模式，使用 <code>segue</code> 方式触发时必须在<code>prepareForSegue:sender:</code>里修改模式。</li>
</ul>
<h4 id="iOS-8-的变化"><a href="#iOS-8-的变化" class="headerlink" title="iOS 8 的变化"></a>iOS 8 的变化</h4><p>iOS 8 引入了适应性布局，由此添加了两种新的方式来显示一个视图控制器：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showViewController</span><span class="params">(<span class="number">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showDetailViewController</span><span class="params">(<span class="number">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></div></pre></td></tr></table></figure><br>这两个方法咋看上去是给 <code>UISplitViewController</code> 用的，在 <code>storyboard</code> 里 <code>segue</code> 的候选模式里，直接给出了<code>Show(e.g. Push)</code>和<code>Show Detail(e.g. Replace)</code>这样的提示，以至于我之前一直对这两个 segue 有误解。实际上这两个方法智能判断当前的显示环境来决定如何显示，iOS 8 想统一显示视图控制器的方式，不过引入这两个方法增加了使用的复杂性，来看看这两个方法的使用规则。<br>这两个方法在 <code>UISplitViewController</code> 上的确是按名字显示的那样去工作的，而在本文关注的控制器上是这样工作的：<br>|  |ViewController|NavigationController|TabBarController|<br>|:——-|:——-|:——–|:——–|<br>|showViewController:sender: |Presentation| Push | Presentation(by self) |<br>|showDetailViewController:sender: |Presentation| Presentation(by self) | Presentation(by self)|<br><code>UINavigationController</code> 重写了<code>showViewController:sender:</code>而执行 <code>push</code> 操作，上面的<code>by self</code>意思是用容器 <code>VC</code> 本身而非其下子 <code>VC</code> 去执行 <code>presentation</code>。这两个方法的行为可以通过重写来改变。<br>当非容器类 VC 内嵌在这两种容器 VC 里时，会通过最近的容器 VC 来执行：<br>||VC in NavigationController|VC in TabBarController|<br>|:——-|:——-|:——–|<br>|showViewController:sender: |Push(by NavigationController)| Presentation(by TabBarController) |<br>|showDetailViewController:sender: |Presentation(by NavigationController)| Presentation(by TabBarController) |</p>
<h3 id="转场五大工具"><a href="#转场五大工具" class="headerlink" title="转场五大工具"></a>转场五大工具</h3><p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p>
<h4 id="转场代理-Transition-Delegate-："><a href="#转场代理-Transition-Delegate-：" class="headerlink" title="转场代理(Transition Delegate)："></a>转场代理(Transition Delegate)：</h4><p>有如下三种容器转场代理，对应上面三种类型的转场：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="type">UINavigationControllerDelegate</span>&gt; <span class="comment">//UINavigationController 的 delegate 属性遵守该协议。</span></div><div class="line">&lt;<span class="type">UITabBarControllerDelegate</span>&gt; <span class="comment">//UITabBarController 的 delegate 属性遵守该协议。</span></div><div class="line">&lt;<span class="type">UIViewControllerTransitioningDelegate</span>&gt; <span class="comment">//UIViewController 的 transitioningDelegate 属性遵守该协议。</span></div></pre></td></tr></table></figure><br>这里除了<uiviewcontrollertransitioningdelegate>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</uiviewcontrollertransitioningdelegate></p>
<h4 id="动画控制器-Animation-Controller-："><a href="#动画控制器-Animation-Controller-：" class="headerlink" title="动画控制器(Animation Controller)："></a>动画控制器(Animation Controller)：</h4><p>最重要的部分，负责添加视图以及执行动画；遵守<uiviewcontrolleranimatedtransitioning>协议；由我们实现。</uiviewcontrolleranimatedtransitioning></p>
<h4 id="交互控制器-Interaction-Controller-："><a href="#交互控制器-Interaction-Controller-：" class="headerlink" title="交互控制器(Interaction Controller)："></a>交互控制器(Interaction Controller)：</h4><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<uiviewcontrollerinteractivetransitioning>协议；系统已经打包好现成的类供我们使用。</uiviewcontrollerinteractivetransitioning></p>
<h4 id="转场环境-Transition-Context"><a href="#转场环境-Transition-Context" class="headerlink" title="转场环境(Transition Context):"></a>转场环境(Transition Context):</h4><p>提供转场中需要的数据；遵守<uiviewcontrollercontexttransitioning>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</uiviewcontrollercontexttransitioning></p>
<h4 id="转场协调器-Transition-Coordinator-："><a href="#转场协调器-Transition-Coordinator-：" class="headerlink" title="转场协调器(Transition Coordinator)："></a>转场协调器(Transition Coordinator)：</h4><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<uiviewcontrollertransitioncoordinator>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</uiviewcontrollertransitioncoordinator></p>
<p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p>
<h2 id="特殊的-Modal-转场"><a href="#特殊的-Modal-转场" class="headerlink" title="特殊的 Modal 转场"></a>特殊的 Modal 转场</h2><p>容器类 VC 的转场里 <code>fromView</code> 和 <code>toView</code> 是 <code>containerView</code> 的子层次的视图，而 Modal 转场里 <code>presentingView</code> 与 <code>containerView</code> 是同层次的视图，只有 <code>presentedView</code> 是 <code>containerView</code> 的子层次视图。<br><img src="/images/semi-transparent.png"></p>
<h3 id="iOS-8引入的UIPresentationController"><a href="#iOS-8引入的UIPresentationController" class="headerlink" title="iOS 8引入的UIPresentationController"></a>iOS 8引入的UIPresentationController</h3><p><code>UIPresentationController</code>类，该类接管了 <code>UIViewController</code> 的显示过程，为其提供转场和视图管理支持。在 iOS 8.0 以上的系统里，你可以在 <code>presentation</code> 转场结束后打印视图控制器的结构，会发现 <code>presentedVC</code> 是由一个<code>UIPresentationController</code>对象来显示的，查看视图结构也能看到 <code>presentedView</code> 是 <code>UIView</code> 私有子类的<code>UITtansitionView</code>的子视图，这就是前面 <code>containerView</code> 的真面目.<br>当<code>UIViewController</code>的<code>modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 <code>Modal 转场</code>进行进一步的定制。实际上该类也可以在<code>.FullScreen</code>模式下使用，但是会丢失由该类负责的动画，保险起见还是遵循官方的建议，只在<code>.Custom</code>模式下使用该类。<br><code>UIPresentationController</code>类赋予 Modal 转场以下特性：</p>
<ol>
<li>定制 <code>presentedView</code> 的外观，尺寸以及在 <code>containerView</code> 中添加自定义视图并为这些视图添加动画；</li>
<li>可以选择是否移除 <code>presentingView</code></li>
<li>可以在不需要动画控制器的情况下单独工作</li>
<li>iOS 8 中的自适应适应性布局<br><code>UIPresentationController</code>类提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：<figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionWillBegin</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionDidEnd</span><span class="params">(<span class="number">_</span> completed: Bool)</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionWillBegin</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionDidEnd</span><span class="params">(<span class="number">_</span> completed: Bool)</span></span></div></pre></td></tr></table></figure>
除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色：<figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指定初始化方法。</span></div><div class="line"><span class="keyword">init</span>(presentedViewController presentedViewController: <span class="type">UIViewController</span>, presentingViewController presentingViewController: <span class="type">UIViewController</span>)</div><div class="line"><span class="keyword">var</span> presentingViewController: <span class="type">UIViewController</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"><span class="keyword">var</span> presentedViewController: <span class="type">UIViewController</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"><span class="keyword">var</span> containerView: <span class="type">UIView</span>? &#123; <span class="keyword">get</span> &#125;</div><div class="line"><span class="comment">//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentedView</span><span class="params">()</span></span> -&gt; <span class="type">UIView</span>?    </div></pre></td></tr></table></figure>
没有 <code>presentingView</code> 是因为 <code>Custom</code> 模式下 <code>presentingView</code> 不受 <code>containerView</code> 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 <code>Modal</code> 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 <code>presentedView</code> 包装在其他视图后重写该方法返回包装后的视图当做 <code>presentedView</code> 在动画控制器中使用。</li>
</ol>
<h3 id="定制presentedView"><a href="#定制presentedView" class="headerlink" title="定制presentedView"></a>定制presentedView</h3><h4 id="外观：重载size方法和frameOfPresentedViewInContainerView属性"><a href="#外观：重载size方法和frameOfPresentedViewInContainerView属性" class="headerlink" title="外观：重载size方法和frameOfPresentedViewInContainerView属性"></a>外观：重载size方法和frameOfPresentedViewInContainerView属性</h4><p>重载存储属性：get方法返回登场页面的位置和大小<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> frameOfPresentedViewInContainerView: <span class="type">CGRect</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> presentViewFrame = <span class="type">CGRect</span>.zero</div><div class="line">    <span class="keyword">let</span> containerBounds = containerView?.bounds</div><div class="line">    <span class="comment">//登场控制器内容页面的大小</span></div><div class="line">    presentViewFrame.size = size(forChildContentContainer: presentedViewController, </div><div class="line">                                  withParentContainerSize: (containerBounds?.size)!)</div><div class="line">    presentViewFrame.origin.x = (containerBounds?.size.width)! - presentViewFrame.size.width</div><div class="line">    <span class="keyword">return</span> presentViewFrame</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//返回登场控制器内容页面的大小，在这里设置为屏幕宽度的三分之一款</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(forChildContentContainer container: UIContentContainer, </span></span></div><div class="line">                   withParentContainerSize parentSize: CGSize) -&gt; <span class="type">CGSize</span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">CGSize</span>.<span class="keyword">init</span>(width:<span class="type">CGFloat</span>(floorf(<span class="type">Float</span>(parentSize.width/<span class="number">3.0</span>))), height: parentSize.height)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="过渡动画，转场协调器-Transition-Coordinator"><a href="#过渡动画，转场协调器-Transition-Coordinator" class="headerlink" title="过渡动画，转场协调器(Transition Coordinator)"></a>过渡动画，转场协调器(Transition Coordinator)</h4><p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 <code>UIViewController</code> 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 <code>nil</code>。</p>
<h5 id="转场开始"><a href="#转场开始" class="headerlink" title="转场开始"></a>转场开始</h5><ol>
<li>在<code>containerView</code>中插入过渡视图<code>chromeView</code></li>
<li>为转场中<code>chromeView</code>过渡视图添加转场动画</li>
<li><code>presentedViewController.transitionCoordinator</code>转场协调器，添加转场的登场和退场动画<figure class="highlight swift"><figcaption><span>presentationTransitionWillBegin</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionWillBegin</span><span class="params">()</span></span> </div><div class="line">&#123;</div><div class="line">    chromeView.frame = (<span class="keyword">self</span>.containerView?.bounds)!</div><div class="line">    chromeView.alpha = <span class="number">0.0</span></div><div class="line">    <span class="comment">//在`containerView`中插入视图`chromeView`    </span></div><div class="line">    containerView?.insertSubview(chromeView, at:<span class="number">0</span>)</div><div class="line">    <span class="comment">//coordinator转场协调器负责转场动画的呈现和dismissal</span></div><div class="line">    <span class="keyword">let</span> coordinator = presentedViewController.transitionCoordinator</div><div class="line">    <span class="keyword">if</span> (coordinator != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="comment">//添加登场动画</span></div><div class="line">        coordinator!.animate(alongsideTransition: &#123;</div><div class="line">        (context:<span class="type">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">            <span class="comment">//animate the alpha to 1.0.</span></div><div class="line">            <span class="keyword">self</span>.chromeView.alpha = <span class="number">1.0</span></div><div class="line">        &#125;, completion:<span class="literal">nil</span>)</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        chromeView.alpha = <span class="number">1.0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="转场结束"><a href="#转场结束" class="headerlink" title="转场结束"></a>转场结束</h5><p>在<code>presentedViewController.transitionCoordinator</code>转场协调器中添加转场的退场动画<br><figure class="highlight swift"><figcaption><span>dismissalTransitionWillBegin</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionWillBegin</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> coordinator = presentedViewController.transitionCoordinator</div><div class="line">    <span class="keyword">if</span> (coordinator != <span class="literal">nil</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//添加退场动画</span></div><div class="line">        coordinator!.animate(alongsideTransition: &#123;</div><div class="line">        (context:<span class="type">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">            <span class="keyword">self</span>.chromeView.alpha = <span class="number">0.0</span></div><div class="line">        &#125;, completion:<span class="literal">nil</span>)</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        chromeView.alpha = <span class="number">0.0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="适配屏幕旋转"><a href="#适配屏幕旋转" class="headerlink" title="适配屏幕旋转"></a>适配屏幕旋转</h4><p>在设备旋转的情况下，重置背景视图的外观和登场控制器内容的外观<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">containerViewWillLayoutSubviews</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    chromeView.frame = (containerView?.bounds)!</div><div class="line">    presentedView?.frame = frameOfPresentedViewInContainerView</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Modal的两种PresentationStyle"><a href="#Modal的两种PresentationStyle" class="headerlink" title="Modal的两种PresentationStyle"></a>Modal的两种PresentationStyle</h4><ol>
<li>设置整个转场动画是否将覆盖全屏幕<br> <code>.OverFullScreen</code>: 浮动式全屏，即：登场视图下方的视图不会完全被遮挡<br> <code>.FullScreen</code>  : 全覆盖全屏 即：占据全屏来显示登场视图<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置整个转场动画是否将覆盖全屏幕</span></div><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> shouldPresentInFullscreen: <span class="type">Bool</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> adaptivePresentationStyle: <span class="type">UIModalPresentationStyle</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">UIModalPresentationStyle</span>.fullScreen</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="交互式转场"><a href="#交互式转场" class="headerlink" title="交互式转场"></a>交互式转场</h2><h3 id="实现交互化"><a href="#实现交互化" class="headerlink" title="实现交互化"></a>实现交互化</h3><p>在非交互转场的基础上将之交互化需要两个条件：<br>由转场代理提供交互控制器，这是一个遵守<uiviewcontrollerinteractivetransitioning>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。<br>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</uiviewcontrollerinteractivetransitioning></p>
<h3 id="使用一个变量来标记交互状态配合转场交互"><a href="#使用一个变量来标记交互状态配合转场交互" class="headerlink" title="使用一个变量来标记交互状态配合转场交互"></a>使用一个变量来标记交互状态配合转场交互</h3><p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束。<br>在两个容器控制器<code>NavigationController</code>和<code>TabBarController</code>转场为例：</p>
<ol>
<li>在 <code>NavigationController</code> 中点击 <code>NavigationBar</code> 也能实现 <code>pop</code> 返回操作，但此时没有了交互手段的支持，转场过程卡壳；</li>
<li>在 <code>TabBarController</code> 的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</li>
</ol>
<h3 id="转场动画控制器：向转场中添加视图，执行转场动画"><a href="#转场动画控制器：向转场中添加视图，执行转场动画" class="headerlink" title="转场动画控制器：向转场中添加视图，执行转场动画"></a>转场动画控制器：向转场中添加视图，执行转场动画</h3><p>转场 API 是协议的好处是不受限于具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同。<br>但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。<br><code>UIViewControllerAnimatedTransitioning</code>代理协议方法，提供了转场所需要的重要数据：</p>
<ol>
<li><code>containerView()</code>：运行转场动画的容器视图</li>
<li>转场视图控制器<ul>
<li>方法一：<code>viewController(forKey:)</code>：<code>UITransitionContextViewControllerKey</code>枚举值：<code>from</code>，<code>to</code></li>
<li>方法二：<code>viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)</code>:iOS 8新增 API 用于方便获取参与转场的视图.两个键值：<code>UITransitionContextFromViewKey</code>,<code>UITransitionContextToViewKey</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleAnimatedTransitioning</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//used to determine if the presentation animation is presenting (as opposed to dismissing).</span></div><div class="line">    <span class="keyword">var</span> isPresentation : <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line"></div><div class="line">    <span class="comment">//returns the duration in seconds of the transition animation.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//返回动画时间</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0.5</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//get the respective views of these view controllers. </span></div><div class="line">    <span class="comment">//Next we get the container view and if the presentation animation is presenting, we add the to view to the container view.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//get the from and to view controllers from the UIViewControllerContextTransitioning object.</span></div><div class="line">        <span class="keyword">let</span> fromVC = transitionContext.viewController(forKey: <span class="type">UITransitionContextViewControllerKey</span>.from)</div><div class="line">        <span class="keyword">let</span> toVC = transitionContext.viewController(forKey: <span class="type">UITransitionContextViewControllerKey</span>.to)</div><div class="line">        <span class="comment">//determine the start and end positions of the view.</span></div><div class="line">        <span class="keyword">let</span> fromView = fromVC?.view</div><div class="line">        <span class="keyword">let</span> toView = toVC?.view</div><div class="line">        <span class="keyword">let</span> containerView = transitionContext.containerView</div><div class="line"></div><div class="line">        <span class="keyword">if</span> isPresentation </div><div class="line">        &#123;</div><div class="line">            containerView.addSubview(toView!)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//decide on which view controller to animate based on whether the transition is a presentation or dismissal</span></div><div class="line">        <span class="keyword">let</span> animatingVC = isPresentation ? toVC : fromVC</div><div class="line">        <span class="keyword">let</span> animatingView = animatingVC?.view</div><div class="line"></div><div class="line">        <span class="keyword">let</span> finalFrameForVC = transitionContext.finalFrame(<span class="keyword">for</span>: animatingVC!)</div><div class="line">        <span class="keyword">var</span> initialFrameForVC = finalFrameForVC</div><div class="line">        <span class="comment">//This will animate the view from right to left during a presentation and vice versa during dismissal.</span></div><div class="line">        initialFrameForVC.origin.x += initialFrameForVC.size.width</div><div class="line"></div><div class="line">        <span class="keyword">let</span> initialFrame = isPresentation ? initialFrameForVC : finalFrameForVC</div><div class="line">        <span class="keyword">let</span> finalFrame = isPresentation ? finalFrameForVC : initialFrameForVC</div><div class="line"></div><div class="line">        animatingView?.frame = initialFrame</div><div class="line">        <span class="comment">//根据协议中的方法获取动画的时间。</span></div><div class="line">        <span class="keyword">let</span> duration = transitionDuration(using: transitionContext)</div><div class="line">        <span class="type">UIView</span>.animate(withDuration: duration, delay:<span class="number">0</span>, usingSpringWithDamping:<span class="number">300.0</span>, initialSpringVelocity:<span class="number">5.0</span>, options:<span class="type">UIViewAnimationOptions</span>.allowUserInteraction, animations:&#123;</div><div class="line"></div><div class="line">            <span class="comment">//we move the view to the final position.</span></div><div class="line">            animatingView?.frame = finalFrame</div><div class="line"></div><div class="line">        &#125;, completion:&#123; (value: <span class="type">Bool</span>) <span class="keyword">in</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>.isPresentation &#123;</div><div class="line">                <span class="comment">//If the transition is a dismissal, we remove the view.</span></div><div class="line">                fromView?.removeFromSuperview()</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//we complete the transition by calling transitionContext.completeTransition()</span></div><div class="line">            transitionContext.completeTransition(<span class="literal">true</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//    UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in</span></div><div class="line">    <span class="comment">//    let isCancelled = transitionContext.transitionWasCancelled()</span></div><div class="line">    <span class="comment">//    transitionContext.completeTransition(!isCancelled)</span></div><div class="line">    <span class="comment">//    &#125;)</span></div><div class="line">    </div><div class="line">    <span class="comment">//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationEnded</span><span class="params">(<span class="number">_</span> transitionCompleted: Bool)</span></span> &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="转场代理协议-Transition-Delegate"><a href="#转场代理协议-Transition-Delegate" class="headerlink" title="转场代理协议(Transition Delegate)"></a>转场代理协议(Transition Delegate)</h2><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。</p>
<h3 id="实现转场代理协议方法，整合动画控制器和自定义展示控制器"><a href="#实现转场代理协议方法，整合动画控制器和自定义展示控制器" class="headerlink" title="实现转场代理协议方法，整合动画控制器和自定义展示控制器"></a>实现转场代理协议方法，整合动画控制器和自定义展示控制器</h3><ol>
<li>返回管理用户信息视图控制器如何展示的控制器。前面实现的<code>ExamplePresentationViewController</code>类可同时处理 <code>presentation</code>转场 和 <code>dismissal</code> 转场。</li>
<li>动画控制器为 <code>presentation</code> 和 <code>dismissal</code> 转场分别提供了动画控制器。<blockquote>
<p><code>UIPresentationController</code>只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。</p>
</blockquote>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleTransitioningDelegate</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerTransitioningDelegate</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//returns a presentation controller that manages the presentation of a view controller.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentationController</span><span class="params">(forPresented presented: UIViewController, </span></span></div><div class="line">                                            presenting: UIViewController?, </div><div class="line">                                                source: UIViewController) -&gt; <span class="type">UIPresentationController</span>? </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//presentation动画控制器</span></div><div class="line">        <span class="keyword">let</span> presentationController = <span class="type">ExamplePresentationViewController</span>(presentedViewController:presented, </div><div class="line">                                                                                    presenting:presenting)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> presentationController</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//为presentation转场提供登场转场动画控制器</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController, </span></span></div><div class="line">                                         presenting: UIViewController, </div><div class="line">                                             source: UIViewController) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//登场转场动画控制器</span></div><div class="line">        <span class="keyword">let</span> animator = <span class="type">ExampleAnimatedTransitioning</span>()</div><div class="line">        animator.isPresentation = <span class="literal">true</span></div><div class="line">        <span class="keyword">return</span> animator</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//为dismissal 转场提供退场转场动画控制器</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//退场转场动画控制器</span></div><div class="line">        <span class="keyword">let</span> animator = <span class="type">ExampleAnimatedTransitioning</span>()</div><div class="line">        animator.isPresentation = <span class="literal">false</span></div><div class="line">        <span class="keyword">return</span> animator</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用自定义的转场的代理"><a href="#使用自定义的转场的代理" class="headerlink" title="使用自定义的转场的代理"></a>使用自定义的转场的代理</h3><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。<br>UIViewControllerTransitioningDelegate转场代理：</p>
<ol>
<li>强引用代理变量:强引用的变量来维护该代理</li>
<li>Modal转场代理的特性：由presentedVC自身来遵循转场代理<code>presentedVC.modalPresentationStyle</code>，和前两个容器控制器转场代理不同。</li>
<li>两种支持自定义转场模式：<code>.Custom</code>或<code>.FullScreen</code>,默认值为<code>.FullScreen</code><figure class="highlight swift"><figcaption><span>fromVC.class</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//强引用的变量来维护该代理</span></div><div class="line"><span class="keyword">let</span> exampleTransitionDelegate = <span class="type">ExampleTransitioningDelegate</span>()</div><div class="line"><span class="comment">//create an instance of ExampleViewController which will provide the content to display.</span></div><div class="line"><span class="keyword">let</span> presentedVC = <span class="type">ExampleViewController</span>()</div><div class="line">presentedVC.modalPresentationStyle = .custom</div><div class="line">presentedVC.transitioningDelegate = exampleTransitionDelegate</div><div class="line"></div><div class="line"><span class="comment">//present this view controller.</span></div><div class="line">present(toVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="两种常规的转场方式"><a href="#两种常规的转场方式" class="headerlink" title="两种常规的转场方式"></a>两种常规的转场方式</h2><h3 id="UIView方式-transitionFromView"><a href="#UIView方式-transitionFromView" class="headerlink" title="UIView方式:transitionFromView"></a>UIView方式:transitionFromView</h3><p>不需要获取 <code>containerView</code> 以及手动添加 <code>toView</code> 就能实现一个指定类型的转场动画，而缺点则是只能使用指定类型的动画。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.transitionFromView(fromView, toView: toView, duration: durantion, options: .<span class="type">TransitionCurlDown</span>, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line"><span class="keyword">let</span> isCancelled = transitionContext.transitionWasCancelled()</div><div class="line">transitionContext.completeTransition(!isCancelled)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="UIViewController方式：在子-VC-间转换的方法"><a href="#UIViewController方式：在子-VC-间转换的方法" class="headerlink" title="UIViewController方式：在子 VC 间转换的方法"></a>UIViewController方式：在子 VC 间转换的方法</h3><p>该方法用 toVC 的视图转换 fromVC 的视图在父视图中的位置，并且执行<code>animations闭包</code>里的动画。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transitionFromViewController:toViewController:duration:options:animations:completion:</div></pre></td></tr></table></figure><br>该方法仅限于在自定义容器控制器里使用，如果直接使用 <code>UINavigationController</code> 和 <code>UITabBarController</code> 调用该方法执行子VC间转换会抛出异常。</p>
<blockquote>
<p>不过 iOS 7 中这两个容器控制器开放的自定义转场做的是同样的事情，回头再看第一章 Transition 解释，转场协议 API 将这个方法拆分成了上面的几个组件，并且加入了激动人心的交互控制，以便我们能够方便定制转场动画。</p>
</blockquote>
<p><a href="http://www.appcoda.com/presentation-controllers-tutorial/" target="_blank" rel="external">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;触发转场的方式&quot;&gt;&lt;a href=&quot;#触发转场的方式&quot; class=&quot;headerlink&quot; title=&quot;触发转场的方式&quot;&gt;&lt;/a&gt;触发转场的方式&lt;/h2&gt;&lt;h3 id=&quot;官方支持的自定义转场&quot;&gt;&lt;a href=&quot;#官方支持的自定义转场&quot; class=&quot;head
    
    </summary>
    
      <category term="iOS" scheme="https://huos3203.github.io/categories/iOS/"/>
    
    
      <category term="转场" scheme="https://huos3203.github.io/tags/%E8%BD%AC%E5%9C%BA/"/>
    
      <category term="动画" scheme="https://huos3203.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>整理iOS中几种常用的展示型视图控制器</title>
    <link href="https://huos3203.github.io/2017/02/16/iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%95%E7%A4%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://huos3203.github.io/2017/02/16/iOS中几种常用的展示控制器使用/</id>
    <published>2017-02-16T09:53:18.000Z</published>
    <updated>2017-02-16T13:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.dropbox.com/s/4gj6levvlav2xzc/PresentationsDemoStart.zip?dl=0" target="_blank" rel="external">开始项目</a><br><a href="https://github.com/appcoda/Presentation-Controllers-Demo" target="_blank" rel="external">完整项目</a></p>
<h2 id="UIAlertController"><a href="#UIAlertController" class="headerlink" title="UIAlertController"></a>UIAlertController</h2><p>在iOS8中，提供<code>UIAlertController</code>控制器代替<code>UIAlertView</code>和<code>UIActionSheet</code>两个控件。给用户展示提示信息的新的一种方式。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>能够自适应的（在iPad上，an <code>action sheet</code> style alert will present itself in a popover），</li>
<li>显示方式：可以轻松切换<code>Action sheets</code>和<code>alert view</code>两种显示样式<code>alert view</code>被以modal态显示presenting视图控制器上，<code>Action sheets</code>被固定在以屏幕底部。 </li>
<li>按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。</li>
<li>子控件支持：<code>Alert view</code>支持按钮和输入框两种，Action sheets仅支持按钮一种控件。</li>
<li>不同于以往的两类<code>UIAlertController</code>继承自<code>UIViewController</code>。这意味着可以使用视图控制器提供展示信息的功能。</li>
</ol>
<h3 id="创建使用UIAlertController"><a href="#创建使用UIAlertController" class="headerlink" title="创建使用UIAlertController"></a>创建使用UIAlertController</h3><p>用<code>title</code>，<code>message</code>参数来实例化<code>alertController</code>实例，然后在实例中添加两个闭包的按钮<br><figure class="highlight swift"><figcaption><span>showAlertWasTapped</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showAlertWasTapped</span><span class="params">(sender: UIButton)</span></span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Appcoda"</span>, message: <span class="string">"Message in alert dialog"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">Alert</span>)</div><div class="line"></div><div class="line">    <span class="keyword">let</span> deleteAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Delete"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Destructive</span>, handler: &#123;(alert :<span class="type">UIAlertAction</span>!) <span class="keyword">in</span></div><div class="line">        <span class="built_in">println</span>(<span class="string">"Delete button tapped"</span>)</div><div class="line">    &#125;)</div><div class="line">    alertController.addAction(deleteAction)</div><div class="line"></div><div class="line">    <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>, handler: &#123;(alert :<span class="type">UIAlertAction</span>!) <span class="keyword">in</span></div><div class="line">        <span class="built_in">println</span>(<span class="string">"OK button tapped"</span>)</div><div class="line">    &#125;)</div><div class="line">    alertController.addAction(okAction)</div><div class="line"></div><div class="line">    presentViewController(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>运行效果：<br><img src="/images/iPhoneipadalert.png"></p>
<h3 id="UIAlertControllerStyle枚举：Alert切换ActionSheet"><a href="#UIAlertControllerStyle枚举：Alert切换ActionSheet" class="headerlink" title="UIAlertControllerStyle枚举：Alert切换ActionSheet"></a>UIAlertControllerStyle枚举：<code>Alert</code>切换<code>ActionSheet</code></h3><p>在<code>UIAlertController</code>之前，切换<code>alert</code>和<code>action sheet</code>需要重写大量的代码，但现在只需要改变一个枚举值<code>UIAlertControllerStyle.Alert</code>为<code>UIAlertControllerStyle.ActionSheet</code>.<br><figure class="highlight swift"><figcaption><span>UIAlertControllerStyle.ActionSheet</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Appcoda"</span>, message: <span class="string">"Message in alert dialog"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">ActionSheet</span>)</div></pre></td></tr></table></figure><br>在iPhone上，屏幕底部显示一个<code>action sheet</code>。<br>问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。</p>
<h3 id="popoverPresentationController锚点：sourceView-sourceRect"><a href="#popoverPresentationController锚点：sourceView-sourceRect" class="headerlink" title="popoverPresentationController锚点：sourceView/sourceRect"></a>popoverPresentationController锚点：sourceView/sourceRect</h3><p><code>popover controller</code>在<code>alertController</code>视图内展示，需要一个<code>popover箭头</code>指向<code>alertController</code>视图的某一位置。<br>通过设置<code>sourceView</code>来确定<code>popover箭头</code>位置，这个<code>popover</code>以及<code>popover箭头</code>指向的矩形区域都在这个<code>sourceView</code>上。<br>在调用<code>presentViewController()</code>之前添加代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alertController.popoverPresentationController?.sourceView = view</div><div class="line">alertController.popoverPresentationController?.sourceRect = sender.frame</div></pre></td></tr></table></figure><br><img src="/images/popover箭头.png"></p>
<h2 id="UIPopoverPresentationController"><a href="#UIPopoverPresentationController" class="headerlink" title="UIPopoverPresentationController"></a>UIPopoverPresentationController</h2><p><code>Alert</code>主要用于显示用户的提示信息，当展示的信息很多时，就需要借助<code>popover presentation controller</code>。</p>
<h3 id="在compact和regular两种屏幕中显示模态视图"><a href="#在compact和regular两种屏幕中显示模态视图" class="headerlink" title="在compact和regular两种屏幕中显示模态视图"></a>在compact和regular两种屏幕中显示模态视图</h3><p>在<code>storyboard</code>文件，设置视图的<code>storyboard ID</code>:<code>PopoverViewController</code>，设置模态视图展示样式，展示在<code>compact-width</code>和<code>regular-width</code>的两种设备屏幕上。<br>实现如下：<br><figure class="highlight swift"><figcaption><span>actionWasTapped</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">actionWasTapped</span><span class="params">(sender: UIBarButtonItem)</span></span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> storyboard : <span class="type">UIStoryboard</span> = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">let</span> vc = storyboard.instantiateViewControllerWithIdentifier(<span class="string">"PopoverViewController"</span>) <span class="keyword">as</span>! <span class="type">UIViewController</span></div><div class="line">    vc.modalPresentationStyle = <span class="type">UIModalPresentationStyle</span>.<span class="type">Popover</span></div><div class="line">    <span class="keyword">let</span> popover: <span class="type">UIPopoverPresentationController</span> = vc.popoverPresentationController!</div><div class="line">    popover.barButtonItem = sender  <span class="comment">//`popover箭头`锚的位置</span></div><div class="line">    presentViewController(vc, animated: <span class="literal">true</span>, completion:<span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="设置锚点四种方式"><a href="#设置锚点四种方式" class="headerlink" title="设置锚点四种方式"></a>设置锚点四种方式</h4><ol>
<li>barButtonItem<br>先获取该视图控制器的<code>popoverPresentationController</code>控制器，通过<code>popover</code>控制器的<code>barButtonItem</code>属性来设置锚点控件。当弹出时<code>popover箭头</code>就指向这个barButtonItem控件。</li>
<li>通过指定<code>sourceView</code>和<code>sourceRect</code>两个属性，就像前面例子中一样来指定锚点位置。</li>
<li>通过其他属性来实现，例如：<code>permittedArrowDirections</code>，也能够指定锚点。</li>
<li>如果在在展示过程中，无法确定箭头的方向时，就是用默认值：<code>UIPopoverArrowDirection.Any</code>.<br>在iPad显示：</li>
</ol>
<img src="/images/UIPopoverArrowDirection.png">
<p>在iPhone上以模态显示：</p>
<img src="/images/iPhonemodally.png">
<h3 id="在iPhone设备上dissmiss模态视图"><a href="#在iPhone设备上dissmiss模态视图" class="headerlink" title="在iPhone设备上dissmiss模态视图"></a>在iPhone设备上dissmiss模态视图</h3><p>要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循<code>UIPopoverPresentationController</code>协议，实现两个代理方法</p>
<h4 id="实现UIPopoverPresentationController协议"><a href="#实现UIPopoverPresentationController协议" class="headerlink" title="实现UIPopoverPresentationController协议"></a>实现<code>UIPopoverPresentationController</code>协议</h4><ol>
<li><code>PopoverViewController</code>类定义修改如下:<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PopoverViewController</span>: <span class="title">UIViewController</span>, <span class="title">UIPopoverPresentationControllerDelegate</span> </span>&#123;</div></pre></td></tr></table></figure></li>
<li>在actionWasTapped()函数中调用<code>presentViewController()</code>之前添加：<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">popover.delegate = <span class="keyword">self</span></div></pre></td></tr></table></figure>
<h4 id="方法一：返回自适应设备的视图展示样式"><a href="#方法一：返回自适应设备的视图展示样式" class="headerlink" title="方法一：返回自适应设备的视图展示样式"></a>方法一：返回自适应设备的视图展示样式</h4>当APP在<code>compact-width</code>设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。<br>这里OS系统被告知在<code>compact-width</code>设备上，使用全屏的样式展示视图。<figure class="highlight swift"><figcaption><span>adaptivePresentationStyleForPresentationController()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">adaptivePresentationStyleForPresentationController</span><span class="params">(controller: UIPresentationController)</span></span> -&gt; <span class="type">UIModalPresentationStyle</span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">UIModalPresentationStyle</span>.<span class="type">FullScreen</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法二：返回自定义的视图控制器"><a href="#方法二：返回自定义的视图控制器" class="headerlink" title="方法二：返回自定义的视图控制器"></a>方法二：返回自定义的视图控制器</h4>当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的<code>Popover presentation</code>展示方式，但是我们指定在<code>compact-width</code>设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。<figure class="highlight swift"><figcaption><span>presentationController(_:viewControllerForAdaptivePresentationStyle)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationController</span><span class="params">(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle)</span></span> -&gt; <span class="type">UIViewController</span>? </div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> navigationController = <span class="type">UINavigationController</span>(rootViewController: controller.presentedViewController)</div><div class="line">    <span class="keyword">let</span> btnDone = <span class="type">UIBarButtonItem</span>(title: <span class="string">"Done"</span>, style: .<span class="type">Done</span>, target: <span class="keyword">self</span>, action: <span class="string">"dismiss"</span>)</div><div class="line">    navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone</div><div class="line">    <span class="keyword">return</span> navigationController</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Done按钮的dismiss事件"><a href="#Done按钮的dismiss事件" class="headerlink" title="Done按钮的dismiss事件"></a><code>Done</code>按钮的dismiss事件</h4><p>在导航控制器中国封装这个视图，在导航条上添加一个<code>Done</code>按钮，点击<code>Done</code>dismiss这个视图<br><figure class="highlight swift"><figcaption><span>dismiss</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismiss</span><span class="params">()</span></span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。<br>在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。<br><img src="/images/adaptivePresentationStyleForPresentationController.png"><br>如果想让iPhone像iPad一样显示一个Popover，只<code>adaptivePresentationStyleForPresentationController</code>返回：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="type">UIModalPresentationStyle</span>.<span class="type">None</span></div></pre></td></tr></table></figure><br><img src="/images/UIModalPresentationStyle.None.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.dropbox.com/s/4gj6levvlav2xzc/PresentationsDemoStart.zip?dl=0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开始项目&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;h
    
    </summary>
    
      <category term="iOS" scheme="https://huos3203.github.io/categories/iOS/"/>
    
    
      <category term="转场" scheme="https://huos3203.github.io/tags/%E8%BD%AC%E5%9C%BA/"/>
    
      <category term="UI" scheme="https://huos3203.github.io/tags/UI/"/>
    
      <category term="动画" scheme="https://huos3203.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huos3203.github.io/2017/02/15/Playground%E4%B8%AD%E4%BD%BF%E7%94%A8XCPlaygroundModule/"/>
    <id>https://huos3203.github.io/2017/02/15/Playground中使用XCPlaygroundModule/</id>
    <published>2017-02-15T09:50:33.000Z</published>
    <updated>2017-02-15T09:50:33.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript自动化组件OC桥接</title>
    <link href="https://huos3203.github.io/2017/02/15/JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6OC%E6%A1%A5%E6%8E%A5/"/>
    <id>https://huos3203.github.io/2017/02/15/JavaScript自动化组件OC桥接/</id>
    <published>2017-02-15T09:19:30.000Z</published>
    <updated>2017-02-16T05:43:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8" target="_blank" rel="external">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p>
<h2 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjC.import(<span class="string">'Cocoa'</span>)</div><div class="line">$.NSBeep()</div></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjC.import(<span class="string">'/Library/Frameworks/Awesome.framework'</span>)</div></pre></td></tr></table></figure></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p>
<p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p>
<blockquote>
<p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p>
</blockquote>
<h2 id="实例化的类和调用方法"><a href="#实例化的类和调用方法" class="headerlink" title="实例化的类和调用方法"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str = $.NSMutableString.alloc.init</div></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str = $.NSString.alloc.initWithUTF8String(<span class="string">'foo'</span>)</div><div class="line">str.writeToFileAtomically(<span class="string">'/tmp/foo'</span>, <span class="literal">true</span>)</div></pre></td></tr></table></figure></p>
<p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.NSNumber.numberWithInt(<span class="number">99</span>).intValue</div></pre></td></tr></table></figure></p>
<h3 id="访问-ObjC-Properties"><a href="#访问-ObjC-Properties" class="headerlink" title="访问 ObjC Properties"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">task = $.NSTask.alloc.init</div><div class="line">task.running == task.isRunning</div></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">task.launchPath = <span class="string">'/bin/sleep'</span></div><div class="line">task.setLaunchPath(<span class="string">'/bin/sleep'</span>)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10
    
    </summary>
    
      <category term="macOS" scheme="https://huos3203.github.io/categories/macOS/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="语法" scheme="https://huos3203.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="搭建" scheme="https://huos3203.github.io/tags/%E6%90%AD%E5%BB%BA/"/>
    
      <category term="测试" scheme="https://huos3203.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="混编" scheme="https://huos3203.github.io/tags/%E6%B7%B7%E7%BC%96/"/>
    
      <category term="管理" scheme="https://huos3203.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>macOS支持JavaScript自动化组件基础</title>
    <link href="https://huos3203.github.io/2017/02/15/macOS%E6%94%AF%E6%8C%81JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>https://huos3203.github.io/2017/02/15/macOS支持JavaScript自动化组件基础/</id>
    <published>2017-02-15T09:19:30.000Z</published>
    <updated>2017-02-16T05:43:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>苹果 <code>OS X Yosemite系统</code>把 <code>JavaScript</code>作为<code>AppleScript</code>的另一选择。<code>Automation</code> 是 <code>OS X 10.10版本</code>中的新特性，苹果在官网发布<a href="https://developer.apple.com/library/prerelease/mac/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/index.html#//apple_ref/doc/uid/TP40014508" target="_blank" rel="external">JavaScript for Automation Release Notes</a>有篇文章介绍了用<code>JavaScript</code>写自动化<code>Automation</code>脚本。<br><code>JavaScript</code>凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。<br>再加上<code>JavaScript</code>先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入<code>OS X平台</code>代替私有的<code>AppleScript</code>，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。<br>资源<br><a href="https://github.com/tylergaw/js-osx-app-examples" target="_blank" rel="external">JavaScript OS X App Examples</a><br><a href="https://github.com/dtinth/JXA-Cookbook" target="_blank" rel="external">JavaScript for Automation Cookbook</a></p>
<h2 id="OSA框架-Open-Scripting-Architecture"><a href="#OSA框架-Open-Scripting-Architecture" class="headerlink" title="OSA框架:Open Scripting Architecture"></a>OSA框架:<code>Open Scripting Architecture</code></h2><p><code>OSA</code>组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：<code>Script Editor</code>编辑器，全系统的<code>Script菜单</code>，<code>Run JavaScript Automator</code>命令的操作，<code>applets</code>小程序，命令行<code>osascript</code>工具，<code>NSUserScriptTask API</code>中，还可以运用在其他的<code>OSA</code>组件中例如：<code>AppleScript</code>。这也就包括了<code>Mail</code>规则、<code>Folder</code>操作、<code>Address Book</code>插件、日历闹钟和消息触发器。</p>
<h2 id="脚本字典"><a href="#脚本字典" class="headerlink" title="脚本字典"></a>脚本字典</h2><p>脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在<code>Script Editor</code>脚本字典浏览器已经更新到显示术语<code>AppleScript</code>，<code>JavaScript</code>和O<code>bjective-C</code>（Scripting Bridge framework）格式。</p>
<h3 id="打开脚本字典"><a href="#打开脚本字典" class="headerlink" title="打开脚本字典"></a>打开脚本字典</h3><p>启动<code>Script Editor</code> (/Applications/Utilities/) –&gt;<code>File &gt; Open Dictionary or Window &gt; Library</code>。</p>
<h2 id="object-specifier"><a href="#object-specifier" class="headerlink" title="object specifier"></a>object specifier</h2><p>在<code>JavaScript自动化主机</code>环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的<code>JavaScript属性</code>时，会返回一个新的<code>object specifier</code>，也就是这个对象的<code>specifier 属性</code>。</p>
<blockquote>
<p>object specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。</p>
</blockquote>
<h2 id="访问APP"><a href="#访问APP" class="headerlink" title="访问APP"></a>访问APP</h2><p>六种方式:<br><figure class="highlight js"><figcaption><span>By name</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Application(<span class="string">'Mail'</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><figcaption><span>By bundle ID</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Application(<span class="string">'com.apple.mail'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>By path</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Application(<span class="string">'/Applications/Mail.app'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>By process ID</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Application(<span class="number">763</span>)</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>On a remote machine</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Application(<span class="string">'eppc://127.0.0.1/Mail'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>currentApplication</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Application.currentApplication()</div></pre></td></tr></table></figure>
<h2 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h2><figure class="highlight js"><figcaption><span>Access properties</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mail.name</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>Access elements</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mail.outgoingMessages[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>Call commands</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mail.open(...)</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>Create new objects</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mail.OutgoingMessage(...)</div></pre></td></tr></table></figure>
<h3 id="属性的get-set方法"><a href="#属性的get-set方法" class="headerlink" title="属性的get/set方法"></a>属性的get/set方法</h3><p>点运算符访问脚本对象，是JavaScript语法特性之一。<br>如上所述，返回的对象是一个<code>object specifier</code>是一个对象的引用，而不是属性实际值。<br>当访问属性时，会作为一个get函数，返回实际值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject = Mail.inbox.messages[<span class="number">0</span>].subject()</div></pre></td></tr></table></figure><br>当赋值属性时，会作为一个set函数，把参数赋值该属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mail.outgoingMessages[<span class="number">0</span>].subject = <span class="string">'Hello world'</span></div></pre></td></tr></table></figure><br>获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subjects = Mail.inbox.messages.subject()</div></pre></td></tr></table></figure></p>
<h3 id="元素数组"><a href="#元素数组" class="headerlink" title="元素数组"></a>元素数组</h3><p>通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问<br><figure class="highlight js"><figcaption><span>索引</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span> = Mail.windows.at(<span class="number">0</span>)</div><div class="line"><span class="built_in">window</span> = Mail.windows[<span class="number">0</span>]</div></pre></td></tr></table></figure><br><figure class="highlight js"><figcaption><span>name</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span> = Mail.windows.byName(<span class="string">'New Message'</span>)</div><div class="line"><span class="built_in">window</span> = Mail.windows[<span class="string">'New Message'</span>]</div></pre></td></tr></table></figure><br><figure class="highlight js"><figcaption><span>ID</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span> = Mail.windows.byId(<span class="number">412</span>)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Note: 使用ID来访问不是方括号[]而是().</p>
</blockquote>
<h3 id="调用命令"><a href="#调用命令" class="headerlink" title="调用命令"></a>调用命令</h3><p>命令被称为函数。</p>
<ol>
<li>直接参数的函数，该参数作为命令的第一个参数传递。</li>
<li>如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。</li>
<li>如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。</li>
<li>如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。</li>
<li>直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。<figure class="highlight js"><figcaption><span>无参数命令</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message.open()</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight js"><figcaption><span>无参数名的命令</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Mail.open(message)</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>带参数名的命令</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">response = message.reply(&#123;</div><div class="line"><span class="attr">replayAll</span>: <span class="literal">true</span>,</div><div class="line"><span class="attr">openingWindow</span>: <span class="literal">false</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>Command with direct parameter and named parameters</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Safari.doJavaScript(<span class="string">'alert("Hello world")'</span>, &#123;</div><div class="line"><span class="attr">in</span>: Safari.windows[<span class="number">0</span>].tabs[<span class="number">0</span>]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Creating-Objects"><a href="#Creating-Objects" class="headerlink" title="Creating Objects"></a>Creating Objects</h2><p>通过调用<code>类构造函数</code>初始化<code>属性</code>和<code>数据</code>来创建新对象。<br>在创建对象时,需要执行的其中步骤：</p>
<ol>
<li><code>make()</code>方法：调用对象上的<code>make()</code>方法来实例化对象。</li>
<li><code>push()</code>方法：调用对象数组上的<code>push</code>方法来实例化对象。<br>在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。</li>
</ol>
<h3 id="Create-a-new-object"><a href="#Create-a-new-object" class="headerlink" title="Create a new object."></a>Create a new object.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">message = Mail.OutgoingMessage().make()</div></pre></td></tr></table></figure>
<h3 id="Create-a-new-object-with-properties"><a href="#Create-a-new-object-with-properties" class="headerlink" title="Create a new object with properties."></a>Create a new object with properties.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">message = Mail.OutgoingMessage(&#123;</div><div class="line"><span class="attr">subject</span>: <span class="string">'Hello world'</span>,</div><div class="line"><span class="attr">visible</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">Mail.outgoingMessages.push(message)</div></pre></td></tr></table></figure>
<h3 id="Create-a-new-object-with-data"><a href="#Create-a-new-object-with-data" class="headerlink" title="Create a new object with data."></a>Create a new object with data.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">para = TextEdit.Paragraph(&#123;&#125;, <span class="string">'Some text'</span>)</div><div class="line">TextEdit.documents[<span class="number">0</span>].paragraphs.push(para)</div></pre></td></tr></table></figure>
<h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>一旦你在应用程序中创建一个新的对象（通过调用<code>make</code>或<code>push</code>），可以像任何现有的应用程序对象一样进行交互。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message = Mail.OutgoingMessage().make()</div><div class="line">message.subject = <span class="string">'Hello world'</span></div></pre></td></tr></table></figure></p>
<h3 id="Scripting-Additions"><a href="#Scripting-Additions" class="headerlink" title="Scripting Additions"></a>Scripting Additions</h3><p>使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。<br>使用这些，必须明确设置<code>includeStandardAdditions</code>的<code>flag</code>为 <code>true</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app = Application.currentApplication()</div><div class="line">app.includeStandardAdditions = <span class="literal">true</span></div><div class="line">app.say(<span class="string">'Hello world'</span>)</div><div class="line">app.displayDialog(<span class="string">'Please enter your email address'</span>, &#123;</div><div class="line"><span class="attr">withTitle</span>: <span class="string">'Email'</span>,</div><div class="line"><span class="attr">defaultAnswer</span>: <span class="string">'your_email@site.com'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="Applets"><a href="#Applets" class="headerlink" title="Applets"></a>Applets</h2><p>在<code>Script Editor</code>编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为<code>Applet</code>。<br>程序支持以下事件处理：<br>当Applet运行时，<code>run</code>处理事件被调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>用于拖放操作的<code>openDocuments</code>处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">openDocuments</span>(<span class="params">docs</span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure><br>传递的参数是一个文件路径字符串数组。<br><a href="https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8" target="_blank" rel="external">更多样例</a></p>
<h2 id="UI-Automation"><a href="#UI-Automation" class="headerlink" title="UI Automation"></a>UI Automation</h2><p>通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器<code>Script Editor</code>中浏览<code>System Events</code>的脚本字典，特别是进程套件<code>Processes Suite</code>，以查看支持此类型自动化的应用程序接口元素的列表。<br>下面的示例使用UI脚本创建Notes中的新注释。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Notes = Application(<span class="string">'Notes'</span>)</div><div class="line">Notes.activate()</div><div class="line"></div><div class="line">delay(<span class="number">1</span>)</div><div class="line">SystemEvents = Application(<span class="string">'System Events'</span>)</div><div class="line">Notes = SystemEvents.processes[<span class="string">'Notes'</span>]</div><div class="line"></div><div class="line">Notes.windows[<span class="number">0</span>].splitterGroups[<span class="number">0</span>].groups[<span class="number">1</span>].groups[<span class="number">0</span>].buttons[<span class="number">0</span>].click()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果 &lt;code&gt;OS X Yosemite系统&lt;/code&gt;把 &lt;code&gt;JavaScript&lt;/code&gt;作为&lt;code&gt;AppleScript&lt;/code&gt;的另一选择。&lt;code&gt;Automation&lt;/code&gt; 是 &lt;code&gt;OS X 10.10版本&lt;/cod
    
    </summary>
    
      <category term="macOS" scheme="https://huos3203.github.io/categories/macOS/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="语法" scheme="https://huos3203.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="混编" scheme="https://huos3203.github.io/tags/%E6%B7%B7%E7%BC%96/"/>
    
      <category term="管理" scheme="https://huos3203.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="JavaScript" scheme="https://huos3203.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>shell命令+AppleScript脚本+Swift代码相互调用</title>
    <link href="https://huos3203.github.io/2017/02/15/shell%E5%91%BD%E4%BB%A4+AppleScript%E8%84%9A%E6%9C%AC+Swift%E4%BB%A3%E7%A0%81%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"/>
    <id>https://huos3203.github.io/2017/02/15/shell命令+AppleScript脚本+Swift代码相互调用/</id>
    <published>2017-02-15T09:19:30.000Z</published>
    <updated>2017-02-15T09:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是<code>AppleScript</code>作为互通的桥梁。</p>
<h2 id="NSTask调用AppleScript"><a href="#NSTask调用AppleScript" class="headerlink" title="NSTask调用AppleScript"></a><code>NSTask</code>调用<code>AppleScript</code></h2><h3 id="调用脚本文件main-scpt"><a href="#调用脚本文件main-scpt" class="headerlink" title="调用脚本文件main.scpt"></a>调用脚本文件<code>main.scpt</code></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//let bundle = NSBundle.init(forClass: self.dynamicType)</span></div><div class="line"><span class="keyword">let</span> bundle = <span class="type">NSBundle</span>.mainBundle()</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> scriptPath = bundle.pathForResource(<span class="string">"main"</span>, ofType: <span class="string">"scpt"</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> paths = [scriptPath]</div><div class="line">    <span class="type">NSTask</span>.launchedTaskWithLaunchPath(<span class="string">"/usr/bin/osascript"</span>, arguments: paths)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="调用APPleScript脚本片段"><a href="#调用APPleScript脚本片段" class="headerlink" title="调用APPleScript脚本片段"></a>调用<code>APPleScript脚本片段</code></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> bundle = <span class="type">NSBundle</span>.mainBundle()</div><div class="line"><span class="keyword">let</span> videoPath = bundle.pathForResource(<span class="string">"BigBuck"</span>, ofType: <span class="string">"m4v"</span>)</div><div class="line"><span class="comment">//https://developer.apple.com/library/mac/technotes/tn2084/_index.html</span></div><div class="line"><span class="comment">//open -na /Applications/mpv.app命令行必须是 -na 才能调用当前指定的播放器，否则会调用系统默认播发器</span></div><div class="line"><span class="keyword">let</span> myAppleScript = <span class="string">"on run\ndo shell script \"open -na /Applications/mpv.app \(videoPath!)\"\ntell application \"mpv\" to activate\n end run"</span></div><div class="line"><span class="built_in">print</span>(myAppleScript)</div><div class="line"><span class="keyword">var</span> error: <span class="type">NSDictionary</span>?</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> scriptObject = <span class="type">NSAppleScript</span>(source: myAppleScript) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> output: <span class="type">NSAppleEventDescriptor</span> = scriptObject.executeAndReturnError(</div><div class="line">    &amp;error) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">print</span>(output.stringValue)</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="literal">nil</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"error: \(error)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AppleScript调用shell"><a href="#AppleScript调用shell" class="headerlink" title="AppleScript调用shell"></a><code>AppleScript</code>调用<code>shell</code></h2><p>AppleScript语句中为on run {变量名称，逗号隔开} 以endrun结束。中间为AppleScript语句。</p>
<h3 id="do-shell-script"><a href="#do-shell-script" class="headerlink" title="do shell script"></a>do shell script</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">on run [变量1,变量2...]  #开始 多个变量名称，用逗号隔开</div><div class="line">    do shell script "open -n /Applications/mpv.app" #AppleScript语句  </div><div class="line">end run #结束</div></pre></td></tr></table></figure>
<h2 id="终端osascript调用AppleScript"><a href="#终端osascript调用AppleScript" class="headerlink" title="终端osascript调用AppleScript"></a>终端<code>osascript</code>调用<code>AppleScript</code></h2><p><a href="http://www.hackmac.org/tutorials/run-applescript-from-the-command-line/" target="_blank" rel="external">参考</a></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osascript -e &apos;applescript command&apos; #单引号</div></pre></td></tr></table></figure>
<h3 id="打开Finder窗口"><a href="#打开Finder窗口" class="headerlink" title="打开Finder窗口"></a>打开Finder窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osascript -e &apos;tell app &quot;Finder&quot; to make new Finder window&apos;</div></pre></td></tr></table></figure>
<h3 id="打开某个程序同时弹出”Hello-World”提示框"><a href="#打开某个程序同时弹出”Hello-World”提示框" class="headerlink" title="打开某个程序同时弹出”Hello World”提示框"></a>打开某个程序同时弹出”Hello World”提示框</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osascript -e <span class="string">'tell app "applicationname" to display dialog "Hello World"'</span></div></pre></td></tr></table></figure>
<h3 id="设置音量，音量大小范围（0-7）"><a href="#设置音量，音量大小范围（0-7）" class="headerlink" title="设置音量，音量大小范围（0-7）"></a>设置音量，音量大小范围（0-7）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osascript -e <span class="string">"set volume number"</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是&lt;code&gt;AppleScript&lt;/code&gt;作为互通的桥梁。&lt;/p&gt;
&lt;h2 id=&quot;NSTask调用AppleScript&quot;&gt;&lt;a href=&quot;#NSTask
    
    </summary>
    
      <category term="macOS" scheme="https://huos3203.github.io/categories/macOS/"/>
    
    
      <category term="脚本" scheme="https://huos3203.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="语法" scheme="https://huos3203.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="混编" scheme="https://huos3203.github.io/tags/%E6%B7%B7%E7%BC%96/"/>
    
      <category term="管理" scheme="https://huos3203.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="shell" scheme="https://huos3203.github.io/tags/shell/"/>
    
      <category term="AppleScript" scheme="https://huos3203.github.io/tags/AppleScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huos3203.github.io/2017/02/15/JavaScript%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://huos3203.github.io/2017/02/15/JavaScript实现自动化/</id>
    <published>2017-02-15T02:10:52.000Z</published>
    <updated>2017-02-15T09:19:27.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过沙盒中JS脚本访问其他APP</title>
    <link href="https://huos3203.github.io/2017/02/14/%E9%80%9A%E8%BF%87%E6%B2%99%E7%9B%92%E4%B8%ADJS%E8%84%9A%E6%9C%AC%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96APP/"/>
    <id>https://huos3203.github.io/2017/02/14/通过沙盒中JS脚本访问其他APP/</id>
    <published>2017-02-14T10:25:29.000Z</published>
    <updated>2017-02-16T05:43:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用脚本字典里的命令和对象来与其他的应用进行通讯?<br>这个教程将向您展示现在使用 <code>AppleScript</code> 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 <code>AppleScript</code>。</p>
<h2 id="在自己的APP中编写"><a href="#在自己的APP中编写" class="headerlink" title="在自己的APP中编写"></a>在自己的APP中编写</h2><h3 id="编写AppleScript代码"><a href="#编写AppleScript代码" class="headerlink" title="编写AppleScript代码"></a>编写AppleScript代码</h3><p><a href="https://developer.apple.com/library/mac/documentation/applescript/conceptual/applescriptlangguide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983-CH208-SW1" target="_blank" rel="external">AppleScript 脚本指南</a><br>与其他应用进行通讯的脚本一般来说都很短，也容易理解。<code>AppleScript</code> 可以被想做一种传送的机制，而不是一种处理环境。<br>典型脚本:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">on chockify(inputString)</div><div class="line">    set resultString to <span class="string">""</span></div><div class="line"></div><div class="line">        repeat <span class="keyword">with</span> inputStringCharacter <span class="keyword">in</span> inputString</div><div class="line">            set asciiValue to (ASCII number inputStringCharacter)</div><div class="line">            <span class="keyword">if</span> (asciiValue &gt; <span class="number">96</span> and asciiValue &lt; <span class="number">123</span>) then</div><div class="line">                set resultString to resultString &amp; (ASCII character (asciiValue - <span class="number">32</span>))</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">if</span> ((asciiValue &gt; <span class="number">64</span> and asciiValue &lt; <span class="number">91</span>) or (asciiValue = <span class="number">32</span>)) then</div><div class="line">                    set resultString to resultString &amp; inputStringCharacter</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">if</span> (asciiValue &gt; <span class="number">47</span> and asciiValue &lt; <span class="number">58</span>) then</div><div class="line">                        set numberStrings to &#123;<span class="string">"ZERO"</span>, <span class="string">"ONE"</span>, <span class="string">"TWO"</span>, <span class="string">"THREE"</span>, <span class="string">"FOR"</span>, <span class="string">"FIVE"</span>, <span class="string">"SIX"</span>, <span class="string">"SEVEN"</span>, <span class="string">"EIGHT"</span>, <span class="string">"NINE"</span>&#125;</div><div class="line">                        set itemIndex to asciiValue - <span class="number">47</span></div><div class="line">                        set numberString to item itemIndex <span class="keyword">of</span> numberStrings</div><div class="line">                        set resultString to resultString &amp; numberString &amp; <span class="string">" "</span></div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        <span class="keyword">if</span> (asciiValue = <span class="number">33</span>) then</div><div class="line">                            set resultString to resultString &amp; <span class="string">" DUH"</span></div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            <span class="keyword">if</span> (asciiValue = <span class="number">63</span>) then</div><div class="line">                                set resultString to resultString &amp; <span class="string">" IF YOU KNOW WHAT I MEAN"</span></div><div class="line">                            end <span class="keyword">if</span></div><div class="line">                        end <span class="keyword">if</span></div><div class="line">                    end <span class="keyword">if</span></div><div class="line">                end <span class="keyword">if</span></div><div class="line">            end <span class="keyword">if</span></div><div class="line">        end repeat</div><div class="line">        resultString</div><div class="line">end chockify</div></pre></td></tr></table></figure></p>
<h3 id="创建事件描述符-event-descriptor"><a href="#创建事件描述符-event-descriptor" class="headerlink" title="创建事件描述符 (event descriptor)"></a>创建事件描述符 (event descriptor)</h3><ol>
<li>导入Carbon.h<br>它有关于所有的 AppleEvent 的定义。<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Carbon/Carbon.h&gt;</span> // for AppleScript definitions</span></div></pre></td></tr></table></figure></li>
<li>OC中创建<code>chockify</code>事件描述符<br>这是可以在你的脚本和应用之间互相传递的一个数据块。可以把它理解成一个封装好的会去执行某个事件的目标，一个将被调用的函数，以及这个函数的参数。使用一个 <code>NSString</code> 作为参数，创建<code>chockify</code>事件描述符：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSAppleEventDescriptor</span> *)chockifyEventDescriptorWithString:(<span class="built_in">NSString</span> *)inputString</div><div class="line">&#123;</div><div class="line">    <span class="comment">// parameter</span></div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *parameter = [<span class="built_in">NSAppleEventDescriptor</span> descriptorWithString:inputString];</div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *parameters = [<span class="built_in">NSAppleEventDescriptor</span> listDescriptor];</div><div class="line">    [parameters insertDescriptor:parameter atIndex:<span class="number">1</span>]; <span class="comment">// you have to love a language with indices that start at 1 instead of 0</span></div><div class="line"></div><div class="line">    <span class="comment">// target</span></div><div class="line">    ProcessSerialNumber psn = &#123;<span class="number">0</span>, kCurrentProcess&#125;;</div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *target = [<span class="built_in">NSAppleEventDescriptor</span> descriptorWithDescriptorType:typeProcessSerialNumber bytes:&amp;psn length:<span class="keyword">sizeof</span>(ProcessSerialNumber)];</div><div class="line"></div><div class="line">    <span class="comment">// function</span></div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *function = [<span class="built_in">NSAppleEventDescriptor</span> descriptorWithString:<span class="string">@"chockify"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// event</span></div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="built_in">NSAppleEventDescriptor</span> appleEventWithEventClass:kASAppleScriptSuite eventID:kASSubroutineEvent targetDescriptor:target returnID:kAutoGenerateReturnID transactionID:kAnyTransactionID];</div><div class="line">    [event setParamDescriptor:function forKeyword:keyASSubroutineName];</div><div class="line">    [event setParamDescriptor:parameters forKeyword:keyDirectObject];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> event;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="OC中加载-AppleScript"><a href="#OC中加载-AppleScript" class="headerlink" title="OC中加载 AppleScript"></a>OC中加载 AppleScript</h3><p>通过应用包(Application bundle)的一个 <code>URL</code> 可以创建 <code>NSAppleScript</code>的实例。而反过来，脚本也要和上面创建的 <code>chockify 事件描述符</code>一起使用。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *URL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Automation"</span> withExtension:<span class="string">@"scpt"</span>];</div><div class="line"><span class="keyword">if</span> (URL) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSAppleScript</span> *appleScript = [[<span class="built_in">NSAppleScript</span> alloc] initWithContentsOfURL:URL error:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="keyword">self</span> chockifyEventDescriptorWithString:[<span class="keyword">self</span>.chockifyInputTextField stringValue]];</div><div class="line">    <span class="built_in">NSDictionary</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *resultEventDescriptor = [appleScript executeAppleEvent:event error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (! resultEventDescriptor) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s AppleScript run error = %@"</span>, __PRETTY_FUNCTION__, error);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *string = [<span class="keyword">self</span> stringForResultEventDescriptor:resultEventDescriptor];</div><div class="line">        [<span class="keyword">self</span> updateChockifyTextFieldWithString:string];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果一切正常的话，你会得到另一个事件描述符。如果出错了，你会得到一个包含了描述错误信息的字典。虽说这个模式和很多其他 <code>Foundation 类</code>很相似，但是返回的错误并不是一个 <code>NSError</code> 的实例。</p>
<h3 id="调用事件描述符"><a href="#调用事件描述符" class="headerlink" title="调用事件描述符"></a>调用事件描述符</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)stringForResultEventDescriptor:(<span class="built_in">NSAppleEventDescriptor</span> *)resultEventDescriptor</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *result = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (resultEventDescriptor)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ([resultEventDescriptor descriptorType] != kAENullEvent)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> ([resultEventDescriptor descriptorType] == kTXNUnicodeTextData) </div><div class="line">            &#123;</div><div class="line">                result = [resultEventDescriptor stringValue];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>InputString 输入可以被正确整形输出，并且你现在也看到想在你的应用里运行 AppleScripts 的方法</p>
<h2 id="调用沙盒中脚本代码与访问其他应用"><a href="#调用沙盒中脚本代码与访问其他应用" class="headerlink" title="调用沙盒中脚本代码与访问其他应用"></a>调用沙盒中脚本代码与访问其他应用</h2><h3 id="了解APP沙盒限制"><a href="#了解APP沙盒限制" class="headerlink" title="了解APP沙盒限制"></a>了解APP沙盒限制</h3><p>如果一段脚本可以轻易地拿到浏览器当前页面上的内容，甚至是在任意标签和窗口运行<code>JavaScript</code>。想象一下如果这些页面里有你的银行账号，或者包含你的信用卡信息什么的。</p>
<p>对于沙盒应用，Apple 所提倡的是通过用户的需要来驱动安全策略。这意味着是否运行你的脚本完全取决于用户。这些脚本可能是来自互联网，也可能是你应用的一部分。一旦得到了权限，脚本就可以以一种受限的方式与系统其他部分进行交互了。<code>NSUserScriptTask</code>使这一切变得可能。<br>由此：Apple 引入了一个新的抽象类 <code>NSUserScriptTask</code>,有三个具体的子类实现:</p>
<ol>
<li><code>NSUserUnixTask</code>: 执行 Unix shell 命令</li>
<li><code>NSUserAutomatorTask</code>: Automator 工作流</li>
<li><code>NSUserAppleScriptTask</code>:执行<code>AppleScript脚本</code>,脚本是异步执行的,所以脚本不能对用户界面做更新操作。</li>
</ol>
<h3 id="开始安装运行脚本"><a href="#开始安装运行脚本" class="headerlink" title="开始安装运行脚本"></a>开始安装运行脚本</h3><p>怎么向用户请求运行脚本的许可，让你的应用与用户的其他应用更好地工作在一起？<br>两种策略:</p>
<ol>
<li>帮助用户来存放运行脚本的位置</li>
<li>获取行脚本目录可读写</li>
</ol>
<h4 id="帮用户存放运行脚本的位置"><a href="#帮用户存放运行脚本的位置" class="headerlink" title="帮用户存放运行脚本的位置"></a>帮用户存放运行脚本的位置</h4><p>只能把把这些脚本放到用户的脚本文件夹(<code>User &gt; Library &gt; Application Scripts/bundle identifier/</code>)中，以只读的方式来运行你的脚本。<br>脚本想要进入这个特定的文件夹的唯一方式就是用用户把它们复制到那里。再者<code>Library 文件夹</code>在 OS X 里默认还是隐藏的。这样对用户都很不友好。<br>让代码来帮助用户打开这个隐藏文件夹：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line"><span class="built_in">NSURL</span> *directoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSApplicationScriptsDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">YES</span> error:&amp;error];</div><div class="line">[[<span class="built_in">NSWorkspace</span> sharedWorkspace] openURL:directoryURL];</div></pre></td></tr></table></figure><br>通过你的应用的某个控件打开这个文件夹，然后进行编辑。这对于用户自己写的脚本来说是个很好的解决方案。</p>
<h4 id="设置运行脚本目录的读写权限"><a href="#设置运行脚本目录的读写权限" class="headerlink" title="设置运行脚本目录的读写权限"></a>设置运行脚本目录的读写权限</h4><ol>
<li>在 Xcode 里，你需要更新 <code>Capabilities</code>，让其包括 <code>User Selected File to Read/Write</code>。在 <code>App Sandbox &gt; File Access</code>里找到相关选项。</li>
<li>用户的意愿是关键，因为你需要获取权限以将脚本添加到文件夹：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line"><span class="built_in">NSURL</span> *directoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSApplicationScriptsDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">YES</span> error:&amp;error];</div><div class="line"><span class="built_in">NSOpenPanel</span> *openPanel = [<span class="built_in">NSOpenPanel</span> openPanel];</div><div class="line">[openPanel setDirectoryURL:directoryURL];</div><div class="line">[openPanel setCanChooseDirectories:<span class="literal">YES</span>];</div><div class="line">[openPanel setCanChooseFiles:<span class="literal">NO</span>];</div><div class="line">[openPanel setPrompt:<span class="string">@"Select Script Folder"</span>];</div><div class="line">[openPanel setMessage:<span class="string">@"Please select the User &gt; Library &gt; Application Scripts &gt; com.iconfactory.Scriptinator folder"</span>];</div><div class="line"></div><div class="line">[openPanel beginWithCompletionHandler:^(<span class="built_in">NSInteger</span> result) &#123;</div><div class="line"><span class="keyword">if</span> (result == <span class="built_in">NSFileHandlingPanelOKButton</span>) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *selectedURL = [openPanel URL];</div><div class="line">    <span class="keyword">if</span> ([selectedURL isEqual:directoryURL])</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSURL</span> *destinationURL = [selectedURL URLByAppendingPathComponent:<span class="string">@"Automation.scpt"</span>];</div><div class="line">        <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">        <span class="built_in">NSURL</span> *sourceURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Automation"</span> withExtension:<span class="string">@"scpt"</span>];</div><div class="line">        <span class="built_in">NSError</span> *error;</div><div class="line">        <span class="built_in">BOOL</span> success = [fileManager copyItemAtURL:sourceURL toURL:destinationURL error:&amp;error];</div><div class="line">        <span class="keyword">if</span> (success)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSAlert</span> *alert = [<span class="built_in">NSAlert</span> alertWithMessageText:<span class="string">@"Script Installed"</span> defaultButton:<span class="string">@"OK"</span> alternateButton:<span class="literal">nil</span> otherButton:<span class="literal">nil</span> informativeTextWithFormat:<span class="string">@"The Automation script was installed succcessfully."</span>];</div><div class="line">            [alert runModal];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%s error = %@"</span>, __PRETTY_FUNCTION__, error);</div><div class="line">            <span class="keyword">if</span> ([error code] == <span class="built_in">NSFileWriteFileExistsError</span>) </div><div class="line">            &#123;</div><div class="line">                <span class="comment">// this is where you could update the script, by removing the old one and copying in a new one</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> </div><div class="line">            &#123;</div><div class="line">                <span class="comment">// the item couldn't be copied, try again</span></div><div class="line">                [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(installAutomationScript:) withObject:<span class="keyword">self</span> afterDelay:<span class="number">0.0</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        <span class="comment">// try again because the user changed the folder path</span></div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(installAutomationScript:) withObject:<span class="keyword">self</span> afterDelay:<span class="number">0.0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
这么一来，应用包中的 <code>Automation.scpt</code> 文件现在暴露在常规的文件系统中了。</li>
</ol>
<h3 id="执行脚本任务"><a href="#执行脚本任务" class="headerlink" title="执行脚本任务"></a>执行脚本任务</h3><p>使用 <code>NSUserAppleScriptTask</code> 来替代 <code>NSAppleScript</code>，来运行上面创建的<code>事件描述符</code>。<br>你大概会经常用到这些脚本任务。文档警告说对于给定的类的某个实例， <code>NSUserAppleScriptTask</code> 不应该被执行多次。所以写一个<code>工厂函数</code>来在需要的时候创建任务：<br><figure class="highlight objc"><figcaption><span>工厂函数</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUserAppleScriptTask</span> *)automationScriptTask</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSUserAppleScriptTask</span> *result = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSError</span> *error;</div><div class="line">    <span class="built_in">NSURL</span> *directoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSApplicationScriptsDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">YES</span> error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (directoryURL) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSURL</span> *scriptURL = [directoryURL URLByAppendingPathComponent:<span class="string">@"Automation.scpt"</span>];</div><div class="line">        result = [[<span class="built_in">NSUserAppleScriptTask</span> alloc] initWithURL:scriptURL error:&amp;error];</div><div class="line">        <span class="keyword">if</span> (! result) </div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%s no AppleScript task error = %@"</span>, __PRETTY_FUNCTION__, error);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// <span class="doctag">NOTE:</span> if you're not running in a sandbox, the directory URL will always be nil</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s no Application Scripts folder error = %@"</span>, __PRETTY_FUNCTION__, error);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果你正在写一个同时适用于沙盒和非沙盒的 Mac 应用的话，在获取 <code>directoryURL</code> 时你需要特别小心。<code>NSApplicationScriptsDirectory</code>只在沙盒中有效。</p>
</blockquote>
<p>在创建脚本任务后，你需要使用 <code>AppleEvent</code> 并提供一个结束处理来执行它：<br><figure class="highlight objc"><figcaption><span>AppleEvent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserAppleScriptTask</span> *automationScriptTask = [<span class="keyword">self</span> automationScriptTask];</div><div class="line"><span class="keyword">if</span> (automationScriptTask) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="keyword">self</span> safariURLEventDescriptor];</div><div class="line">    [automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class="built_in">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="keyword">if</span> (! resultEventDescriptor) </div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%s AppleScript task error = %@"</span>, __PRETTY_FUNCTION__, error);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSURL</span> *URL = [<span class="keyword">self</span> URLForResultEventDescriptor:resultEventDescriptor];</div><div class="line">            <span class="comment">// <span class="doctag">NOTE:</span> The completion handler for the script is not run on the main thread. Before you update any UI, you'll need to get</span></div><div class="line">            <span class="comment">// on that thread by using libdispatch or performing a selector.</span></div><div class="line">            [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateURLTextFieldWithURL:) withObject:URL waitUntilDone:<span class="literal">NO</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>对于用户写的脚本，用户可能期望你的应用只是简单地’运行’脚本 (而不去调用事件描述符中指定的函数)。在这种情况下，你可以为 <code>event</code> 传递一个 <code>nil</code>，脚本就会像用户在 <code>Finder</code> 中双击那样的行为进行执行。<br><code>NSUserAppleScriptTask</code>脚本是异步执行的，所以你的用户界面并不会被一个 (比较长) 的脚本锁住，在结束后会执行回调处理。</p>
<h2 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h2><p><code>NSAppleScript</code> 和 <code>NSUserAppleScriptTask</code> 有一个微妙的区别：新的机制是异步执行的。对于大部分情况，使用一个结束回调来处理会是一个好得多的方式，因为这样就不会因为执行脚本而阻碍你的应用。<br>然而有时候如果你想带有依赖地来执行任务的时候，事情就变得有些取巧了。比方说一个任务需要在另一个任务开始之前必须完成。这种情况下你就会想念 <code>NSAppleScript</code> 的同步特性了。<br>要获得传统方式的行为，一种简单的方法是使用一个<code>信号量(semaphore)</code> 来确保同时只有一个任务运行、在你的类或者应用的初始化方法中，使用 <code>libdispatch</code> 创建一个信号量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.appleScriptTaskSemaphore = dispatch_semaphore_create(<span class="number">1</span>);</div></pre></td></tr></table></figure><br>接下来在初始化脚本任务之前，简单地等待信号量。当任务完成时，标记相同的这个信号量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// wait for any previous tasks to complete before starting a new one — remember that you're blocking the main thread here!</span></div><div class="line">dispatch_semaphore_wait(<span class="keyword">self</span>.appleScriptTaskSemaphore, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line"><span class="comment">// run the script task</span></div><div class="line"><span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="keyword">self</span> openNetworkPreferencesEventDescriptor];</div><div class="line">[automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class="built_in">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="keyword">if</span> (! resultEventDescriptor)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s AppleScript task error = %@"</span>, __PRETTY_FUNCTION__, error);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(showNetworkAlert) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// the task has completed, so let any pending tasks proceed</span></div><div class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.appleScriptTaskSemaphore);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><br>再强调一下，除非确实有所需要，否则最好别这么做。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使用脚本字典里的命令和对象来与其他的应用进行通讯?&lt;br&gt;这个教程将向您展示现在使用 &lt;code&gt;AppleScript&lt;/code&gt; 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 &lt;code&gt;AppleScript&lt;/code
    
    </summary>
    
      <category term="macOS" scheme="https://huos3203.github.io/categories/macOS/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="脚本" scheme="https://huos3203.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="AppleScript" scheme="https://huos3203.github.io/tags/AppleScript/"/>
    
      <category term="沙盒" scheme="https://huos3203.github.io/tags/%E6%B2%99%E7%9B%92/"/>
    
  </entry>
  
  <entry>
    <title>macOS之PDFKit基础</title>
    <link href="https://huos3203.github.io/2017/02/14/macOS%E4%B9%8BPDFKit%E5%9F%BA%E7%A1%80/"/>
    <id>https://huos3203.github.io/2017/02/14/macOS之PDFKit基础/</id>
    <published>2017-02-14T06:29:18.000Z</published>
    <updated>2017-02-14T06:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。<br>作为文件版本，可以支持元数据标记如作者，创建日期，等等。<br>一个文件可以加密，需要密码才能查看它。两级加密存在：</p>
<ul>
<li>用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。</li>
<li>所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。<br>许多加密的PDF文件有一个“dummy”的用户密码为<code>空字符串</code>。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。</li>
</ul>
<h2 id="PDF页面"><a href="#PDF页面" class="headerlink" title="PDF页面"></a>PDF页面</h2><p>一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含<code>超链接</code>和<code>注释</code>。页面可以支持<code>裁剪</code>，还有其他使用功能：例如隐藏多余的部分（如注册标记）。</p>
<h3 id="view-VS-page空间坐标"><a href="#view-VS-page空间坐标" class="headerlink" title="view VS page空间坐标"></a>view VS page空间坐标</h3><p>页面上的大多数对象都是在<code>page</code>空间中指定的，而不是在<code>view</code>空间中。<br>也就是说，坐标系统是在点（每英寸72点），<code>坐标原点</code>在page左侧底部，而不是<code>view</code>。<code>page</code>空间不关心缩放，显示模式等等。一个有<code>bounds</code>的item，比如说32points，保留这些界限，无论显示大小。<br>图view和page坐标系比较<br><img src="/images/view_vspage_space.gif" class="view和page坐标系比较"><br><code>PDFView class</code>包含几个转换方法，将坐标系统从<code>view space</code>的<code>page space</code>，反之亦然。</p>
<h2 id="PDF-Kit-Classes"><a href="#PDF-Kit-Classes" class="headerlink" title="PDF Kit Classes"></a>PDF Kit Classes</h2><p><code>PDF Kit</code>套件提供了几个不同功能的<code>类</code>。<br><code>PDFView</code>和<code>PDFSelection</code>除外，这些<code>类</code>大致对应着各个<code>对象</code>在PDF格式的规范需求。<br><img src="/images/pdfkit_inheritancehierarchy.gif"></p>
<h3 id="PDFView-Class"><a href="#PDFView-Class" class="headerlink" title="PDFView Class"></a>PDFView Class</h3><p><code>PDFView类</code>，就好比Web工具包的<code>WebView类</code>，源于<code>Application Kit</code>中的<code>NSView类</code>。在项目开发中，你可以使用<code>Interface Builder</code>轻松拖动一个<code>PDFView对象</code>放在一个window中。<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br><code>PDFView</code>可能是<code>PDF Kit</code>中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到<code>PDFView</code>。<br><code>PDFView</code>能通过调用其他<code>PDF实用类</code>来实现其大部分功能。如果要添加特殊功能，则需要用户自定义<code>实用类</code>的子类来扩展其特殊功能。<br>Utility classes as used by PDFView<br><img src="/images/pdfkit_uses_hierarchy.gif"></p>
<h3 id="PDF-Kit-Utility-Classes"><a href="#PDF-Kit-Utility-Classes" class="headerlink" title="PDF Kit Utility Classes"></a>PDF Kit Utility Classes</h3><p>PDF套件工具类提供一种混合的<code>Foundation-like</code>和<code>Application Kit-like</code>的行为。他们有类似的<code>NSString类</code>和<code>NSString Additions</code>方法。这些类都系橙自<code>NSObject</code><br><img src="/images/pdfkit_inheritancehierarchy.gif"></p>
<h4 id="PDF-Document"><a href="#PDF-Document" class="headerlink" title="PDF Document"></a>PDF Document</h4><p><code>PDFDocument</code>是<code>PDF kit工具类</code>中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在<code>PDFDocument</code>方法中的实例化。是<code>PDFPage</code>和<code>PDFOutline</code>；或相关支持操作：<code>PDFSelection</code>和<code>PDFDestination</code>。<br>你<code>PDFDocument对象</code>初始化，需要一个<code>PDF数据</code>或一个指向PDF文件的<code>URL</code>。实例化之后就可以访问<code>页数</code>，<code>添加</code>或<code>删除</code>页面，对所选内容为<code>NSString对象</code>进行<code>查找</code>或<code>分析</code>。</p>
<h4 id="PDFPage"><a href="#PDFPage" class="headerlink" title="PDFPage"></a>PDFPage</h4><p><code>PDFPage</code>代表一个PDF文档的页面。你的应用程序获取一个<code>PDFPage</code>对象必须通过从<code>PDFDocument</code>对象来实例化。<code>PDFPage</code>对象是用户所看到的屏幕，和一个<code>view</code>可以同时显示多个<code>page</code>。你可以使用<code>PDFPage</code>把PDF文档内容渲染到屏幕上，添加<code>注释</code>，<code>计数字符串</code>，定义<code>选择</code>，获取一个<code>page</code>中的文本内容作为<code>NSString对象</code>或<code>NSAttributedString对象</code>。</p>
<h4 id="PDFOutline"><a href="#PDFOutline" class="headerlink" title="PDFOutline"></a>PDFOutline</h4><p>除了显示实际的文件内容，<code>PDF Kit</code>也能呈现<code>PDFOutline</code>信息，前提是PDF文档中存在目录结构。在目录结构中，一个<code>PDFOutline对象</code>代表一个<code>父目录</code>或<code>子目录</code>。<br>目录是由一个层次的<code>PDFOutline对象</code>组层。顶层是<code>根目录对象</code>，它仅作为其他目录对象的容器。用户的<code>根目录</code>是不可见的。</p>
<h4 id="PDFSelection"><a href="#PDFSelection" class="headerlink" title="PDFSelection"></a>PDFSelection</h4><p>一个<code>PDFSelection</code>对象包含一个跨PDF文档中文本。你不要直接创建<code>PDFSelection</code>。<code>PDFSelection</code>对象是作为返回值来实例化的。例如：通过调用<code>PDFPage</code>或<code>PDFDocument</code>对象中的selection方法，并从成功搜索的返回值来实例化<code>PDFSelection</code>对象。<br>在同时显示多个<code>PDFPage</code>的<code>PDFView</code>中，<code>PDFSelection</code>可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。</p>
<h4 id="PDFAnnotation"><a href="#PDFAnnotation" class="headerlink" title="PDFAnnotation"></a>PDFAnnotation</h4><p>一个<code>PDFAnnotation</code>对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。<br><code>PDFAnnotation</code>是如图所示的具体类的抽象类。各种具体类代表<code>PDF Kit</code>支持的注释类型。<br><img src="/images/annotations.gif"></p>
<h4 id="PDFBorder"><a href="#PDFBorder" class="headerlink" title="PDFBorder"></a>PDFBorder</h4><p><code>PDFBorder</code>对象封装的拉伸<code>PDFAnnotation</code>对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。</p>
<p>过期:<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br>Here’s what Apple says about it:<br><blockquote><p>“To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Add<br>button, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.”</p>
<footer><strong>老文档</strong><cite><a href="http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/PDFKitGuide/PDFKit_Prog_Tasks/PDFKit_Prog_Tasks.html" target="_blank" rel="external">PDFKit_Prog_Tasks</a></cite></footer></blockquote><br>So:<br>there’s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it.<br>There’s no PDFKit.palette file anywhere on my HD (says Spotlight).<br>I guess these instructions are for an older version of XCode but it’s all Apple seemed to have on it…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。&lt;br&gt;作为文件版本，可以支持元数据标记如作者，创建日期，等等。&lt;br&gt;一个文件可以加密，需要密码才能查看它。两级加密存在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户级加密：如果用户成功地获得
    
    </summary>
    
      <category term="macOS" scheme="https://huos3203.github.io/categories/macOS/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="UI" scheme="https://huos3203.github.io/tags/UI/"/>
    
      <category term="PDF" scheme="https://huos3203.github.io/tags/PDF/"/>
    
      <category term="阅读器" scheme="https://huos3203.github.io/tags/%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Fabric对macOS系统的支持</title>
    <link href="https://huos3203.github.io/2017/02/14/Fabric%E5%AF%B9macOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%AF%E6%8C%81%E8%B0%83%E7%A0%94/"/>
    <id>https://huos3203.github.io/2017/02/14/Fabric对macOS系统的支持调研/</id>
    <published>2017-02-14T03:14:35.000Z</published>
    <updated>2017-02-14T06:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href="https://try.crashlytics.com/" target="_blank" rel="external">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href="https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support" target="_blank" rel="external">浏览官方文档</a></p>
<h3 id="crashlytics支持macOS"><a href="#crashlytics支持macOS" class="headerlink" title="crashlytics支持macOS"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class="string">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</div></pre></td></tr></table></figure>

<p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p>
<footer><strong>官方文档</strong><cite><a href="https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support" target="_blank" rel="external">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p>
<h3 id="Cause-a-Test-Crash教程"><a href="#Cause-a-Test-Crash教程" class="headerlink" title="Cause a Test Crash教程"></a><a href="https://docs.fabric.io/apple/crashlytics/test-crash.html" target="_blank" rel="external">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p>
<ol>
<li><code>run</code>在模拟器上安装运行APP</li>
<li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li>
<li>在模拟器上启动APP，并执行崩溃操作</li>
<li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li>
</ol>
<blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href="https://fabric.io/settings/apps/some_app_id/mappings" target="_blank" rel="external">https://fabric.io/settings/apps/some_app_id/mappings</a></p>
<footer><strong>官方文档</strong><cite><a href="https://docs.fabric.io/apple/crashlytics/test-crash.html" target="_blank" rel="external">Cause a Test Crash教程</a></cite></footer></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Fabric&quot;&gt;&lt;a href=&quot;#Fabric&quot; class=&quot;headerlink&quot; title=&quot;Fabric&quot;&gt;&lt;/a&gt;Fabric&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Fabric&lt;/code&gt; 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件
    
    </summary>
    
      <category term="macOS" scheme="https://huos3203.github.io/categories/macOS/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="搭建" scheme="https://huos3203.github.io/tags/%E6%90%AD%E5%BB%BA/"/>
    
      <category term="测试" scheme="https://huos3203.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="管理" scheme="https://huos3203.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="SDK" scheme="https://huos3203.github.io/tags/SDK/"/>
    
      <category term="发布" scheme="https://huos3203.github.io/tags/%E5%8F%91%E5%B8%83/"/>
    
      <category term="macOS" scheme="https://huos3203.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>思维导图之开发实践篇</title>
    <link href="https://huos3203.github.io/2017/02/13/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <id>https://huos3203.github.io/2017/02/13/思维导图之开发实践篇/</id>
    <published>2017-02-13T09:11:26.000Z</published>
    <updated>2017-02-13T09:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读书籍"><a href="#阅读书籍" class="headerlink" title="阅读书籍"></a>阅读书籍</h2><ul>
<li>5种图表解决工作中的12大难题</li>
<li>你的第一本思维导图操作书</li>
<li>5分钟手绘彩色圆珠笔涂鸦集</li>
<li>如果阅读一本书</li>
</ul>
<p>使用思维导图的场景无处不在，无论是做产品还是做设计，我们都需要清晰的思路，明确自己需要做些什么，最后需要达到什么效果，这时候，如果有一张清晰的思维导图，就能很快的理清自己的思路。作为互联网公司自称是产品型设计师（也就是既需要帮助老板整理需求梳理产品，也要设计漂亮的界面）的我更是如此。 </p>
<p>目的：通过学习在该文章中讲到的开发设计案例，站在项目开发角度，了解从速记到思维导图再到实际开发的过程。<br>从产品、设计等方面谈谈我是如何运用思维导图的。</p>
<h2 id="需求分析——完善最初的想法"><a href="#需求分析——完善最初的想法" class="headerlink" title="需求分析——完善最初的想法"></a>需求分析——完善最初的想法</h2><p>一般老板只会告诉我们大概需要一个什么东西，具体的细节还需要我们去整理。这时候，我会把大概涉及到的基本点写在纸上，想到一条写一条，特别是一些需要注意的地方。</p>
<h3 id="需求速记法"><a href="#需求速记法" class="headerlink" title="需求速记法"></a>需求速记法</h3><p>先用纸笔速记的方式，把临时能想到的点记录下来<br><img src="/images/需求速记.jpg" class="需求速记" width="300" height="500"><br>在纸上列得差不多了，再新建一个 <code>XMind</code> 文档，把之前列的一些点一一转到电脑上，然后整理分类。</p>
<h3 id="功能结构图案例"><a href="#功能结构图案例" class="headerlink" title="功能结构图案例"></a>功能结构图案例</h3><ol>
<li>码市逻辑图<br>通过思维导图能够一目了然的看到码市的功能<img src="https://dn-coding-net-production-pp.qbox.me/fa34c949-b36d-4c86-a1be-a6f6c5459f3e.png"></li>
<li>网站功能逻辑图<br>通过功能主干图直观显示了一个网站或者 APP 整体大功能组成部分，一般在写产品需求文档时需要的功能逻辑图。<img src="https://dn-coding-net-production-pp.qbox.me/535567ad-e51f-43b9-aa66-8b98fc719dc6.png">
<h2 id="产品设计——通过画原型来完善功能结构"><a href="#产品设计——通过画原型来完善功能结构" class="headerlink" title="产品设计——通过画原型来完善功能结构"></a>产品设计——通过画原型来完善功能结构</h2><code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能结构导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<h3 id="悬赏功能结构图"><a href="#悬赏功能结构图" class="headerlink" title="悬赏功能结构图"></a>悬赏功能结构图</h3>为产品原型图考虑，在梳理整理产品功能结构图时，尽可能包括页面上所有需要展示的内容以及基本的交互流程等。<br>下面这个图是码市功能结构中的发布悬赏功能部分：<img src="https://dn-coding-net-production-pp.qbox.me/4b1d61b9-c558-4afc-9aed-54dd47b440be.png" class="码市悬赏功能结构" title="悬赏功能结构">
有了功能结构图，就可以一一对照来做原型了。<h3 id="原型图"><a href="#原型图" class="headerlink" title="原型图"></a>原型图</h3>正如前面所说：<code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<br>然后得到下面的原型：<img src="https://dn-coding-net-production-pp.qbox.me/eb4feccf-3514-41ac-b4de-222db74ef1d9.png">
</li>
</ol>
<h2 id="写文章时用到的思维导图"><a href="#写文章时用到的思维导图" class="headerlink" title="写文章时用到的思维导图"></a>写文章时用到的思维导图</h2><p><a href="https://blog.coding.net/blog/coding-mindmap" target="_blank" rel="external">原文</a><br>把想到的先列出来，慢慢整理调整，梳理出写作思路。<br><img src="/images/QbMJNrM.png!web.png" alt=""><br>演变过程：<br><img src="/images/vIfAjiY.png!web.png" alt=""></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="微信推出应用号的处境："><a href="#微信推出应用号的处境：" class="headerlink" title="微信推出应用号的处境："></a>微信推出应用号的处境：</h3><p><img src="/images/QQ20160114-1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;阅读书籍&quot;&gt;&lt;a href=&quot;#阅读书籍&quot; class=&quot;headerlink&quot; title=&quot;阅读书籍&quot;&gt;&lt;/a&gt;阅读书籍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;5种图表解决工作中的12大难题&lt;/li&gt;
&lt;li&gt;你的第一本思维导图操作书&lt;/li&gt;
&lt;li&gt;5分钟手绘彩色圆珠
    
    </summary>
    
      <category term="逻辑思维" scheme="https://huos3203.github.io/categories/%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="管理" scheme="https://huos3203.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="思维导图" scheme="https://huos3203.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>使用JavaScript把JSON数据转为对象</title>
    <link href="https://huos3203.github.io/2017/02/12/%E4%BD%BF%E7%94%A8JavaScript%E6%8A%8AJSON%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/"/>
    <id>https://huos3203.github.io/2017/02/12/使用JavaScript把JSON数据定义对象/</id>
    <published>2017-02-12T06:41:35.000Z</published>
    <updated>2017-02-16T05:43:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将JSON数据序列化为代码实例"><a href="#将JSON数据序列化为代码实例" class="headerlink" title="将JSON数据序列化为代码实例"></a>将JSON数据序列化为代码实例</h2><ol>
<li>定义一个继承自 <code>JSExport</code> 子协议 <code>PersonJSExports</code></li>
<li>定义一个遵守<code>PersonJSExports</code>协议的<code>Person</code>数据模</li>
<li>使用 <code>JavaScript</code> 把<code>JSON</code>转为<code>类</code>并实例化<code>对象</code><br>都有一个完整的 <code>JVM</code> 在那儿了，谁还需要 <code>NSJSONSerialization</code>？</li>
</ol>
<h2 id="JSExport语言互通协议"><a href="#JSExport语言互通协议" class="headerlink" title="JSExport语言互通协议"></a>JSExport语言互通协议</h2><p><code>JavaScript</code>可以脱离<code>prototype继承</code>完全用<code>JSON</code>来定义对象，但是<code>Objective-C</code>编程不能脱离<code>类</code>和<code>继承</code>。所以<code>JavaScriptCore</code>就提供了<code>JSExport</code>作为两种语言的互通协议。<br><code>JSExport</code>中没有预定义任何方法，但是所有继承<code>JSExport</code>的协议中定义的方法即协议方法，都可以在<code>JSContext</code>中被调用。</p>
<h2 id="JSExportAs-宏-指定方法在JS中调用的名称"><a href="#JSExportAs-宏-指定方法在JS中调用的名称" class="headerlink" title="JSExportAs 宏: 指定方法在JS中调用的名称"></a>JSExportAs 宏: 指定方法在JS中调用的名称</h2><p>对于多参数的方法，<code>JavaScriptCore</code>的转换方式将<code>Objective-C</code>的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MultiArgs</span> &lt;<span class="title">JSExport</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)doFoo:(<span class="keyword">id</span>)foo withBar:(<span class="keyword">id</span>)bar;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br>如果希望方法在JavaScript中有一个比较短的名字，就需要用的JSExport.h中提供的宏：<br><figure class="highlight objc"><figcaption><span>JSExport.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSExportAs(PropertyName, Selector)</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><figcaption><span>JSExportAs的官方宏定义 xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/JavaScriptCore/Reference/JSExport_Ref/index.html</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define JSExportAs(PropertyName, Selector) \</span></div><div class="line"><span class="keyword">@optional</span> Selector __JS_EXPORT_AS__<span class="meta">##PropertyName:(id)argument; @required Selector</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>如 <code>setX:Y:Z</code>方法，我们可以给他重命名，让 JS 中通过 <code>set3D(x,y,z)</code> 来调用<br><figure class="highlight objc"><figcaption><span>使用方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSExportAs(set3D,</div><div class="line">- (<span class="keyword">void</span>)setX:(<span class="keyword">id</span>)x Y:(<span class="keyword">id</span>)y Z:(<span class="keyword">id</span>)z</div><div class="line">);</div><div class="line"><span class="comment">//调用</span></div><div class="line">set3D(x,y,z)</div></pre></td></tr></table></figure></p>
<h3 id="定义PersonJSExports协议和create协议方法（类方法）"><a href="#定义PersonJSExports协议和create协议方法（类方法）" class="headerlink" title="定义PersonJSExports协议和create协议方法（类方法）"></a>定义PersonJSExports协议和create协议方法（类方法）</h3><p><code>Person 类</code>实现了<code>PersonJSExports 协议</code>，该协议规定哪些属性可以在 <code>JavaScript</code>中可用。<br>在<code>JavaScript</code>语境中，不能像：<code>var person = new Person()</code>来初始化实例，可以在定义<code>PersonJSExports</code>协议方法时，添加一个协议方法来弥补这一点。见下例<code>create...</code>类方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Custom protocol must be declared with `@objc`</span></div><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PersonJSExports</span> : <span class="title">JSExport</span> </span>&#123;</div><div class="line">    <span class="comment">//属性</span></div><div class="line">    <span class="keyword">var</span> firstName: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">var</span> lastName: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">var</span> birthYear: <span class="type">NSNumber</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="comment">//方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getFullName</span><span class="params">()</span></span> -&gt; <span class="type">String</span></div><div class="line"></div><div class="line">    <span class="comment">/// 在JavaScript中调用这个类方法</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createWithFirstName</span>(<span class="title">firstName</span>: <span class="title">String</span>, <span class="title">lastName</span>: <span class="title">String</span>) -&gt; <span class="title">Person</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line">### 定义<span class="title">Person</span>模型</div><div class="line">定义一个遵守`<span class="title">PersonJSExports</span>`协议的`<span class="title">Person</span>`数据模</div><div class="line">// <span class="title">Custom</span> <span class="title">class</span> <span class="title">must</span> <span class="title">inherit</span> <span class="title">from</span> `<span class="title">NSObject</span>`</div><div class="line">@<span class="title">objc</span> <span class="title">class</span> <span class="title">Person</span> : <span class="title">NSObject</span>, <span class="title">PersonJSExports</span> &#123;</div><div class="line">    <span class="comment">// JS协议属性必须声明为`dynamic`</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> firstName: <span class="type">String</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> lastName: <span class="type">String</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> birthYear: <span class="type">NSNumber</span>?</div><div class="line"></div><div class="line">    <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>)   </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">self</span>.firstName = firstName</div><div class="line">        <span class="keyword">self</span>.lastName = lastName</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//JS协议类方法</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createWithFirstName</span>(<span class="title">firstName</span>: <span class="title">String</span>, <span class="title">lastName</span>: <span class="title">String</span>) -&gt; <span class="title">Person</span> </span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Person</span>(firstName: firstName, lastName: lastName)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//JS协议方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getFullName</span><span class="params">()</span></span> -&gt; <span class="type">String</span> </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"\(firstName) \(lastName)"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="JSContext-配置"><a href="#JSContext-配置" class="headerlink" title="JSContext 配置"></a>JSContext 配置</h3><p>之前，我们可以用我们已经创建的 Person 类，我们需要将其导出到 <code>JavaScript</code> 环境。我们也将借此导入<a href="http://mustache.github.io" target="_blank" rel="external">Mustache JS library</a>，我们将应用模板到我们的 Person 对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export Person class，JS中以该`Person标示符`作为类名使用</span></div><div class="line">context.setObject(<span class="type">Person</span>.<span class="keyword">self</span>, forKeyedSubscript: <span class="string">"Person"</span>)</div><div class="line"></div><div class="line"><span class="comment">// load Mustache.js</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> mustacheJSString = <span class="type">String</span>(contentsOfFile:..., encoding:<span class="type">NSUTF8StringEncoding</span>, error:<span class="literal">nil</span>) </div><div class="line">&#123;</div><div class="line">    context.evaluateScript(mustacheJSString)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="JavaScript-数据和进程"><a href="#JavaScript-数据和进程" class="headerlink" title="JavaScript 数据和进程"></a>JavaScript 数据和进程</h3><p>下面就来看看我们简单的 JSON 例子，这段代码将创建新的 Person 实例。<br>数据：<br><figure class="highlight json"><figcaption><span>Persons.json</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123; <span class="attr">"first"</span>: <span class="string">"Grace"</span>,     <span class="attr">"last"</span>: <span class="string">"Hopper"</span>,   <span class="attr">"year"</span>: <span class="number">1906</span> &#125;,</div><div class="line">    &#123; <span class="attr">"first"</span>: <span class="string">"Ada"</span>,       <span class="attr">"last"</span>: <span class="string">"Lovelace"</span>, <span class="attr">"year"</span>: <span class="number">1815</span> &#125;,</div><div class="line">    &#123; <span class="attr">"first"</span>: <span class="string">"Margaret"</span>,  <span class="attr">"last"</span>: <span class="string">"Hamilton"</span>, <span class="attr">"year"</span>: <span class="number">1936</span> &#125;</div><div class="line">]</div></pre></td></tr></table></figure><br>创建新的 Person 实例：<br><figure class="highlight js"><figcaption><span>loadPeople.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> loadPeopleFromJSON = <span class="function"><span class="keyword">function</span>(<span class="params">jsonString</span>) </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonString);</div><div class="line">    <span class="keyword">var</span> people = [];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data.length; i++) </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//在swift中的js协议方法：`createWithFirstName:lastName:`</span></div><div class="line">        <span class="keyword">var</span> person = Person.createWithFirstNameLastName(data[i].first, data[i].last);</div><div class="line">        person.birthYear = data[i].year;</div><div class="line">        <span class="comment">//`push:`添加到数组中</span></div><div class="line">        people.push(person);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//返回该对象</span></div><div class="line">    <span class="keyword">return</span> people;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><code>JSContext</code>加载装换<code>loadPeople.js</code>脚本<br>加载js脚本之后，<code>loadPeopleFromJSON</code>即可作为下标被<code>context</code>调用该方法:<br><figure class="highlight swift"><figcaption><span>加载loadPeople.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// load loadPeople.js</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> loadPeople = <span class="type">String</span>(contentsOfFile:..., encoding:<span class="type">NSUTF8StringEncoding</span>, error:<span class="literal">nil</span>) </div><div class="line">&#123;</div><div class="line">    <span class="comment">//加载js脚本之后，`loadPeopleFromJSON`即可作为下标被context调用该方法</span></div><div class="line">    context.evaluateScript(loadPeople)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：JavaScriptCore 转换的 Objective-C / Swift 方法名是 JavaScript 兼容的。由于 JavaScript 没有参数 名称，任何外部参数名称都会被转换为驼峰形式并且附加到函数名后。在这个例子中，Objective-C 的方法 createWithFirstName:lastName: 变成了在JavaScript中的 createWithFirstNameLastName()。</p>
</blockquote>
<h3 id="使用Mustache-模板-渲染"><a href="#使用Mustache-模板-渲染" class="headerlink" title="使用Mustache 模板 渲染"></a>使用Mustache 模板 渲染</h3><p>Mustache 是一个很强大的 template 引擎，可以通过解析 json 来绑定并渲染占位符。如果你做过一些前端开发的话，会知道这是一种很常用的 HTML 绑定 Model 的做法，GRMustache.swift 是这个框架的 Swift 实现。<br><a href="http://blog.csdn.net/kevin_luan/article/details/46485561" target="_blank" rel="external">mustache模板引擎</a><br><a href="https://github.com/BjornRuud/Swiftache" target="_blank" rel="external">Mustache 的 Swift 语言实现版本</a><br>mustache的特点就是很语法很简单，主要语法如下:</p>
<pre><code>1. {{ name }} 打印变量，默认是escape过的，如果不要escape,用3个分隔符 {{{ name }}}，或者用 {{ &name }}，这个和分隔符无关
2. {{#person}}…{{/person}} 区块，4种方式
    person 是真假值，决定是否输出
    person 是list of array，会循环展开 for x in person:section.render(&apos;xxx)
    person 是匿名函数/object, 区块包裹的html 会作为参数传递进去
    person 是dict，直接打印 dict[key]
3. {{^person}}…{{/person}，反向区块
    4. {{！name }} 注释
5. {{> box }} 载入子模块
</code></pre><p>加载 <code>JSON 数据</code>，调用 <code>JSContext</code> 将数据解析成 <code>Person 对象</code>的数组，并用 <code>Mustache 模板</code>呈现每个<code>Person</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从文件`Persons.json`中加载json数据</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> peopleJSON = <span class="type">NSString</span>(contentsOfFile:..., encoding: <span class="type">NSUTF8StringEncoding</span>, error: <span class="literal">nil</span>) </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 获取js中定义的`loadPeopleFromJSON`的方法</span></div><div class="line">    <span class="keyword">let</span> load = context.objectForKeyedSubscript(<span class="string">"loadPeopleFromJSON"</span>)</div><div class="line">    <span class="comment">// 通过调用load方法将`JSON 数据`解析成`Person 对象`的数组</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> people = load.callWithArguments([peopleJSON]).toArray() <span class="keyword">as</span>? [<span class="type">Person</span>] </div><div class="line">    &#123;</div><div class="line">        <span class="comment">// get rendering function and create template</span></div><div class="line">        <span class="keyword">let</span> mustacheRender = context.objectForKeyedSubscript(<span class="string">"Mustache"</span>).objectForKeyedSubscript(<span class="string">"render"</span>)</div><div class="line">        <span class="keyword">let</span> template = <span class="string">", born "</span></div><div class="line"></div><div class="line">        <span class="comment">// loop through people and render Person object as string</span></div><div class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people </div><div class="line">        &#123;</div><div class="line">            <span class="built_in">println</span>(mustacheRender.callWithArguments([template, person]))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Output:</span></div><div class="line"><span class="comment">// Grace Hopper, born 1906</span></div><div class="line"><span class="comment">// Ada Lovelace, born 1815</span></div><div class="line"><span class="comment">// Margaret Hamilton, born 1936</span></div></pre></td></tr></table></figure><br>JavaScript 代码段可能是附带应用一起发布的基本的用户定义的插件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;将JSON数据序列化为代码实例&quot;&gt;&lt;a href=&quot;#将JSON数据序列化为代码实例&quot; class=&quot;headerlink&quot; title=&quot;将JSON数据序列化为代码实例&quot;&gt;&lt;/a&gt;将JSON数据序列化为代码实例&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;定义一个继承自 &lt;cod
    
    </summary>
    
      <category term="swift" scheme="https://huos3203.github.io/categories/swift/"/>
    
    
      <category term="语法" scheme="https://huos3203.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="混编" scheme="https://huos3203.github.io/tags/%E6%B7%B7%E7%BC%96/"/>
    
      <category term="iOS" scheme="https://huos3203.github.io/tags/iOS/"/>
    
      <category term="macOS" scheme="https://huos3203.github.io/tags/macOS/"/>
    
      <category term="Java​Script​Core" scheme="https://huos3203.github.io/tags/Java%E2%80%8BScript%E2%80%8BCore/"/>
    
      <category term="swift" scheme="https://huos3203.github.io/tags/swift/"/>
    
      <category term="json" scheme="https://huos3203.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Java​Script​Core实现swift混编</title>
    <link href="https://huos3203.github.io/2017/02/12/Java%E2%80%8BScript%E2%80%8BCore%E5%AE%9E%E7%8E%B0swift%E6%B7%B7%E7%BC%96/"/>
    <id>https://huos3203.github.io/2017/02/12/Java​Script​Core实现swift混编/</id>
    <published>2017-02-12T05:34:06.000Z</published>
    <updated>2017-02-16T05:43:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>OS X Mavericks 和 iOS 7 引入了 <code>JavaScriptCore</code> 库，它把 <code>WebKit 的 JavaScript</code> 引擎用 <code>Objective-C</code> 封装，提供了简单，快速以及安全的方式接入世界上最流行的语言。不管你爱它还是恨它，<code>JavaScript</code> 的普遍存在使得程序员、工具以及融合到 OS X 和 iOS 里这样超快的虚拟机中资源的使用都大幅增长。</p>
<ol>
<li>如何从 <code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</li>
<li>那么反向呢？怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？</li>
</ol>
<h2 id="swift通过JSContext调用JavaScript"><a href="#swift通过JSContext调用JavaScript" class="headerlink" title="swift通过JSContext调用JavaScript"></a>swift通过JSContext调用JavaScript</h2><p>如何从<code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</p>
<h3 id="全局实例JSContext：运行JavaScript代码的环境"><a href="#全局实例JSContext：运行JavaScript代码的环境" class="headerlink" title="全局实例JSContext：运行JavaScript代码的环境"></a>全局实例JSContext：运行JavaScript代码的环境</h3><p>全局实例<code>JSContext</code>作用就像在浏览器内运行的一个<code>JavaScript</code>脚本，<code>JSContext</code> 类似于 <code>window</code>。<br>通过<code>JSContext</code>实例运行<code>JavaScript</code>代码<code>创建变量</code>，<code>做计算</code>，<code>定义方法</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> context = <span class="type">JSContext</span>()    <span class="comment">//创建全局环境</span></div><div class="line">context.evaluateScript(<span class="string">"var num = 5 + 5"</span>) <span class="comment">//计算</span></div><div class="line">context.evaluateScript(<span class="string">"var names = ['Grace', 'Ada', 'Margaret']"</span>) <span class="comment">//定义变量</span></div><div class="line">context.evaluateScript(<span class="string">"var triple = function(value) &#123; return value * 3 &#125;"</span>) <span class="comment">//定义方法</span></div><div class="line"><span class="keyword">let</span> tripleNum: <span class="type">JSValue</span> = context.evaluateScript(<span class="string">"triple(num)"</span>)  </div></pre></td></tr></table></figure></p>
<h3 id="动态类型JSValue-包裹JSContext环境下每一个可能的JS值"><a href="#动态类型JSValue-包裹JSContext环境下每一个可能的JS值" class="headerlink" title="动态类型JSValue:包裹JSContext环境下每一个可能的JS值"></a>动态类型JSValue:包裹JSContext环境下每一个可能的JS值</h3><p><code>JavaScript</code> 是动态语言，所以动态类型<code>JSValue</code>包裹JSContext环境中任何可能的JS值，字符串和数字；数组、对象和方法；甚至错误和特殊的 JavaScript 值诸如 <code>null</code> 和 <code>undefined</code>。<br>获取<code>tripleNum</code>值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">println</span>(<span class="string">"Tripled: \(tripleNum.toInt32())"</span>)</div></pre></td></tr></table></figure><br><code>JSValue</code> 包括一系列方法用于访问其可能的值以保证有正确的 <code>Foundation 基本类型</code><br>包括：<br><img src="/images/JSValueType.png"></p>
<h3 id="下标取值：访问JSContext环境下的任何值"><a href="#下标取值：访问JSContext环境下的任何值" class="headerlink" title="下标取值：访问JSContext环境下的任何值"></a>下标取值：访问JSContext环境下的任何值</h3><p><code>JSContext</code> 和 <code>JSValue</code> 实例可以使用下标的方式访问之前创建的 <code>context</code> 的任何值。</p>
<ul>
<li><code>JSContext</code>：需要一个字符串下标</li>
<li><code>JSValue</code>：允许使用<code>字符串</code>或<code>整数</code>标来得到里面的对象和数组</li>
</ul>
<h4 id="JSContext下标取值"><a href="#JSContext下标取值" class="headerlink" title="JSContext下标取值"></a>JSContext下标取值</h4><ol>
<li><code>swift</code>语法<figure class="highlight swift"><figcaption><span>未映射成[]的原始方法</span><a href="http://nshipster.cn/object-subscripting/" target="_blank" rel="external">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> names = context.objectForKeyedSubscript(<span class="string">"names"</span>)  <span class="comment">//JSContext字符串下标原始方法</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="JSValue整数下标原始方法"><a href="#JSValue整数下标原始方法" class="headerlink" title="JSValue整数下标原始方法"></a>JSValue整数下标原始方法</h4><figure class="highlight swift"><figcaption><span>未映射成[]的原始方法</span><a href="http://nshipster.cn/object-subscripting/" target="_blank" rel="external">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> initialName = names.objectAtIndexedSubscript(<span class="number">0</span>)   <span class="comment">//JSValue整数下标原始方法</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"The first name: \(initialName.toString())"</span>)  <span class="comment">//JSValue method</span></div><div class="line"><span class="comment">// The first name: Grace</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，Objective-C 代码可以利用下标表示法，如下例：context[@”names”]，names[0]，[initialName toString]，Swift 目前只公开<a href="http://nshipster.cn/object-subscripting/" target="_blank" rel="external">原始方法</a>:<code>objectAtKeyedSubscript()</code> 和 <code>objectAtIndexedSubscript()</code>来让下标成为可能。</p>
</blockquote>
<h3 id="callWithArguments调用JS方法：只需传入Foundation基本类型参数"><a href="#callWithArguments调用JS方法：只需传入Foundation基本类型参数" class="headerlink" title="callWithArguments调用JS方法：只需传入Foundation基本类型参数"></a>callWithArguments调用JS方法：只需传入Foundation基本类型参数</h3><p>上述<code>JavaScript</code>代码中，<code>JSValue</code>包装了一个<code>triple函数</code>，在<code>Objective-C / Swift</code> 代码中可以使用 <code>Foundation基本类型</code>作为参数来直接调用该函数。再次，<code>JavaScriptCore</code> 很轻松的处理了这个桥接：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"><span class="keyword">let</span> tripleFunction = context.objectForKeyedSubscript(<span class="string">"triple"</span>) <span class="comment">//下标取值</span></div><div class="line"><span class="keyword">let</span> result = tripleFunction.callWithArguments([<span class="number">5</span>]) <span class="comment">//传入基本类型参数直接调用</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"Five tripled: \(result.toInt32())"</span>)</div></pre></td></tr></table></figure></p>
<h3 id="exceptionHandler错误处理"><a href="#exceptionHandler错误处理" class="headerlink" title="exceptionHandler错误处理"></a><code>exceptionHandler</code>错误处理</h3><p><code>exceptionHandler</code> 是一个接收<code>JSContext 引用</code>和<code>异常本身</code>的回调处理的闭包。<br>通过设置上下文的 <code>exceptionHandler</code> 属性，可以观察和记录<code>语法</code>，<code>类型</code>以及<code>运行时错误</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">context.exceptionHandler = &#123; context, exception <span class="keyword">in</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"JS Error: \(exception)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">context.evaluateScript(<span class="string">"function multiply(value1, value2) &#123; return value1 * value2 "</span>)</div><div class="line"><span class="comment">// JS Error: SyntaxError: Unexpected end of script</span></div></pre></td></tr></table></figure><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"JS Error: %@"</span>, exception);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[context evaluateScript:<span class="string">@"function multiply(value1, value2) &#123; return value1 * value2 "</span>];</div><div class="line"><span class="comment">// JS Error: SyntaxError: Unexpected end of script</span></div></pre></td></tr></table></figure></p>
<h2 id="JavaScript-通过JSContext调用-swift／OC"><a href="#JavaScript-通过JSContext调用-swift／OC" class="headerlink" title="JavaScript 通过JSContext调用 swift／OC"></a>JavaScript 通过JSContext调用 swift／OC</h2><p>怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？<br>让 <code>JSContext</code> 访问我们的本地客户端代码的方式主要有两种：</p>
<ol>
<li><code>block块</code>键值对：把OC中的<code>block块</code>赋值给<code>JSContext</code>的一个标示键，该标识键的<code>JSValue</code>可以通过<code>callWithArguments</code>调用.</li>
<li><code>JSExport 协议</code>。</li>
</ol>
<h3 id="block块-键值对-该block键的JSValue通过callWithArguments调用"><a href="#block块-键值对-该block键的JSValue通过callWithArguments调用" class="headerlink" title="block块 键值对:该block键的JSValue通过callWithArguments调用"></a>block块 键值对:该block键的<code>JSValue</code>通过<code>callWithArguments</code>调用</h3><p>当一个 <code>Objective-C block</code> 被赋给 <code>JSContext</code> 里的一个标识符，<code>JavaScriptCore</code> 会自动的把 <code>block</code> 封装在 <code>JavaScript 函数</code>里，并以该标示符作为函数名来调用该block的实现。这使得在 <code>JavaScript</code> 中可以简单的使用 <code>Foundation</code> 和 <code>Cocoa</code>类，所有的桥接都为你做好了。<br><a href="http://nshipster.cn/cfstringtransform/" target="_blank" rel="external">CFStringTransform</a>处理语言的强大威力</p>
<p>在 <code>JSContext</code> 中使用 <code>Swift 闭包</code>需要注意两点:</p>
<ol>
<li>与 <code>@objc_block</code> 属性一起声明</li>
<li>使用Swift中的<code>unsafeBitCast()</code>函数，把对象转换为<code>AnyObject</code></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> simplifyString: <span class="meta">@objc</span>_block <span class="type">String</span> -&gt; <span class="type">String</span> = &#123; input <span class="keyword">in</span></div><div class="line">    <span class="keyword">var</span> mutableString = <span class="type">NSMutableString</span>(string: input) <span class="keyword">as</span> <span class="type">CFMutableStringRef</span></div><div class="line">    <span class="type">CFStringTransform</span>(mutableString, <span class="literal">nil</span>, kCFStringTransformToLatin, <span class="type">Boolean</span>(<span class="number">0</span>))</div><div class="line">    <span class="type">CFStringTransform</span>(mutableString, <span class="literal">nil</span>, kCFStringTransformStripCombiningMarks, <span class="type">Boolean</span>(<span class="number">0</span>))</div><div class="line">    <span class="keyword">return</span> mutableString</div><div class="line">&#125;</div><div class="line">context.setObject(<span class="built_in">unsafeBitCast</span>(simplifyString, <span class="type">AnyObject</span>.<span class="keyword">self</span>), forKeyedSubscript: <span class="string">"simplifyString"</span>)</div><div class="line"><span class="comment">//通过simplifyString标示符来调用block的实现</span></div><div class="line"><span class="built_in">println</span>(context.evaluateScript(<span class="string">"simplifyString('안녕하새요!')"</span>))</div><div class="line"><span class="comment">// annyeonghasaeyo!</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给标示符赋值一个oc-block，该标示符会被自动装换为JavaScript函数</span></div><div class="line">context[<span class="string">@"simplifyString"</span>] = ^(<span class="built_in">NSString</span> *input) &#123;</div><div class="line"><span class="built_in">NSMutableString</span> *mutableString = [input mutableCopy];</div><div class="line"><span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)mutableString, <span class="literal">NULL</span>, kCFStringTransformToLatin, <span class="literal">NO</span>);</div><div class="line"><span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)mutableString, <span class="literal">NULL</span>, kCFStringTransformStripCombiningMarks, <span class="literal">NO</span>);</div><div class="line"><span class="keyword">return</span> mutableString;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//通过simplifyString标示符来调用block的实现</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [context evaluateScript:<span class="string">@"simplifyString('안녕하새요!')"</span>]);</div></pre></td></tr></table></figure>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>由于 <code>block</code> 可以保有变量引用，而且 <code>JSContext</code> 也强引用它所有的变量，为了避免强引用循环需要特别小心。<br>避免保有<code>JSContext</code> 或<code>一个 block</code> 里的任何 <code>JSValue</code>。相反，使用 <code>[JSContext currentContext]</code> 得到当前上下文，并把你需要的任何值用参数传递。</p>
<h3 id="JSExport-协议"><a href="#JSExport-协议" class="headerlink" title="JSExport 协议"></a>JSExport 协议</h3><p>在继承<code>JSExport 协议</code>的子协议里声明的属性，实例方法还是类方法，都会自动暴漏给<code>JavaScript</code>代码来调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS X Mavericks 和 iOS 7 引入了 &lt;code&gt;JavaScriptCore&lt;/code&gt; 库，它把 &lt;code&gt;WebKit 的 JavaScript&lt;/code&gt; 引擎用 &lt;code&gt;Objective-C&lt;/code&gt; 封装，提供了简单，快速以及安全
    
    </summary>
    
      <category term="swift" scheme="https://huos3203.github.io/categories/swift/"/>
    
    
      <category term="语法" scheme="https://huos3203.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="混编" scheme="https://huos3203.github.io/tags/%E6%B7%B7%E7%BC%96/"/>
    
      <category term="iOS" scheme="https://huos3203.github.io/tags/iOS/"/>
    
      <category term="macOS" scheme="https://huos3203.github.io/tags/macOS/"/>
    
      <category term="Java​Script​Core" scheme="https://huos3203.github.io/tags/Java%E2%80%8BScript%E2%80%8BCore/"/>
    
      <category term="swift" scheme="https://huos3203.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>用Git将代码恢复到一个历史的版本</title>
    <link href="https://huos3203.github.io/2017/02/10/%E7%94%A8Git%E5%B0%86%E4%BB%A3%E7%A0%81%E6%81%A2%E5%A4%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <id>https://huos3203.github.io/2017/02/10/用Git将代码恢复到一个历史的版本/</id>
    <published>2017-02-10T10:19:48.000Z</published>
    <updated>2017-02-10T10:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果：<br>目的：在当前分支上，将代码恢复到一个历史的提交版本上。</p>
<h2 id="暴力的方式"><a href="#暴力的方式" class="headerlink" title="暴力的方式"></a>暴力的方式</h2><p>如果仓库是自己在用（不影响别人），那么可以使用<code>git reset --hard &lt;target_commit_id&gt;</code> 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。</p>
<ol>
<li>第一步：查看本地的索引的提交日志：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git reflog 		</div><div class="line">a1d09fd HEAD@&#123;0&#125;: checkout: moving from all to master</div><div class="line">a1d09fd HEAD@&#123;1&#125;: checkout: moving from master to all</div><div class="line">a1d09fd HEAD@&#123;2&#125;: checkout: moving from HEAD to master</div><div class="line">a1d09fd HEAD@&#123;3&#125;: checkout: moving from all to HEAD</div></pre></td></tr></table></figure></li>
<li>第二步：根据上面的sh2值，回滚：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset  —hard  a1d09fd</div></pre></td></tr></table></figure>
这样就可以找回代码.</li>
</ol>
<h2 id="温柔的方式"><a href="#温柔的方式" class="headerlink" title="温柔的方式"></a>温柔的方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#回滚</div><div class="line">git reset  —hard  a1d09fd</div><div class="line">#将当前代码切换回最新的提交</div><div class="line">git reset --soft origin/source</div></pre></td></tr></table></figure>
<p>此时工作区变成了历史的提交内容，这个时候用 <code>git add</code> 和 <code>git commit</code> 即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果：&lt;br&gt;目的：在当前分支上，将代码恢复到一个历史的提交版本上。&lt;/p&gt;
&lt;h2 id=&quot;暴力的方式&quot;&gt;&lt;a href=&quot;#暴力的方式&quot; class=&quot;headerlink&quot; title=&quot;暴力的方
    
    </summary>
    
      <category term="git" scheme="https://huos3203.github.io/categories/git/"/>
    
    
      <category term="工具" scheme="https://huos3203.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="https://huos3203.github.io/tags/git/"/>
    
      <category term="语法" scheme="https://huos3203.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
